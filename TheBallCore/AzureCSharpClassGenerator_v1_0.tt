<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>
<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			this.GenerationEnvironment.Clear();
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + ".designer.cs";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InstanceOfTheBallType CurrInstance;
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}

	InformationObjectType GetInformationObjectByName(string informationObjectName)
    {
		var result = CurrInstance.InformationModel.FirstOrDefault(candidate => candidate.name == informationObjectName);
		if(result == null)
			throw new ArgumentException("Information object not found with name: " + informationObjectName);
		return result;
    }

	bool IsItemIndependentMaster(InformationItemType itemType)
    {
		if(string.IsNullOrEmpty(itemType.informationObjectName))
			return false;
		return IsObjectIndependentMaster(itemType.informationObjectName);
    }

	bool IsItemMasterCollection(InformationItemType itemType)
    {
		var masterColl = GetMasterCollectionByName(CurrInstance, itemType.informationObjectName);
		return masterColl != null;
    }

	bool IsObjectIndependentMaster(string informationObjectName)
    {
		var iObject = GetInformationObjectByName(informationObjectName);
		return iObject.isIndependentMaster;
    }
	
	void GenerateAbstraction(TheBallCoreAbstractionType abstraction)
	{
		InstanceOfTheBallType instance = abstraction.InstanceOfTheBall;
		CurrInstance = instance;
		GenerateInstance(instance);
	}	

	void GenerateInstance(InstanceOfTheBallType instance)
	{
		string domainName = instance.semanticDomainName;
		string domainNameMethodPart = domainName.Replace(".", "_");
#>

using DOM=<#= instance.semanticDomainName #>;

namespace TheBall.CORE {
	public static partial class OwnerInitializer
	{
		private static void DOMAININIT_<#= domainNameMethodPart #>(IContainerOwner owner)
		{
			DOM.DomainInformationSupport.EnsureMasterCollections(owner);
			DOM.DomainInformationSupport.RefreshMasterCollections(owner);
		}
	}
}


<#+
		BeginNamespace(instance.semanticDomainName);
#>
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using Microsoft.WindowsAzure.Storage.Blob;
using ProtoBuf;
using TheBall;
using TheBall.CORE;



<#+
		BeginNamespace("INT");
		GenerateInterfaceModel(instance);
		EndBlock(); // namespace
		GenerateDomainInitializer(instance);
		foreach(var informationObject in instance.InformationModel ?? new InformationObjectType[0])
        {
			GenerateInformationObject(informationObject);

        }
		EndBlock(); // namespace
#>

<#+
	}

	string GetTypeFromInterfaceType(InterfaceItemTypeLogicalDataType logicalInterfaceDataType)
    {
		//InterfaceItemTypeLogicalDataType dataType = (InterfaceItemTypeLogicalDataType) System.Enum.Parse(typeof(InterfaceItemTypeLogicalDataType), logicalInterfaceDataType);
		switch(logicalInterfaceDataType)
        {
			case InterfaceItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InterfaceItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InterfaceItemTypeLogicalDataType.Number:
				return "double";
			case InterfaceItemTypeLogicalDataType.Text_Long:
			case InterfaceItemTypeLogicalDataType.Text_Short:
				return "string";
			case InterfaceItemTypeLogicalDataType.Time_Date:
			case InterfaceItemTypeLogicalDataType.Time_DateTime:
			case InterfaceItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			default:
				throw new NotSupportedException("Logical interface data type not supported: " + logicalInterfaceDataType);
        }
    }

	void GenerateInterfaceModel(InstanceOfTheBallType instance)
    {
		if(instance.DigitalInterface == null)
			return;
		foreach(InterfaceObjectType interfaceObject in instance.DigitalInterface.InterfaceModel ?? new InterfaceObjectType[0])
        {
			bool customIDGeneration = interfaceObject.AutomationDefinition != null ? interfaceObject.AutomationDefinition.customIDProvider : false;
			string className = interfaceObject.name;
#>
			[DataContract]
			public partial class <#= interfaceObject.name #>
			{
<#+
			if(customIDGeneration) {
#>
				public <#= className #>() 
				{
					ID = <#= className #>Implementation.GetID();
				}
<#+
            }
#>

<#+
			foreach(var informationField in interfaceObject.InterfaceItems ?? new object[0]) 
			{
				string fieldName;
				string typeName;
				bool isCollection;
				InterfaceItemType iItem = informationField as InterfaceItemType;
				ObjectInstanceType oItem = informationField as ObjectInstanceType;
				if(iItem != null)
                {
					fieldName = iItem.name;
					typeName = GetTypeFromInterfaceType(iItem.logicalDataType);
					isCollection = iItem.isCollection;
                } else if(oItem != null)
                {
					fieldName = oItem.name;
					typeName = oItem.interfaceObjectName;
					isCollection = oItem.isCollection;
                } else 
					throw new NotSupportedException("Field type: " + informationField.GetType().Name + " not supported");
				if(isCollection)
					typeName = typeName + "[]";
#>
				[DataMember]
				public <#= typeName #> <#= fieldName #> { get; set; }
<#+
            }
#>
			}

<#+
        }
    }

	void GenerateDomainInitializer(InstanceOfTheBallType instance)
    {
		var masterCollections = GetMasterCollections(instance);
#>
		public static class DomainInformationSupport
		{
            public static void EnsureMasterCollections(IContainerOwner owner)
            {
<#+
		foreach(var masterColl in masterCollections)
        {
			string masterCollName = masterColl.name;
#>
                {
                    var masterCollection = <#= masterCollName #>.GetMasterCollectionInstance(owner);
                    if(masterCollection == null)
                    {
                        masterCollection = <#= masterCollName #>.CreateDefault();
                        masterCollection.RelativeLocation =
                            <#= masterCollName #>.GetMasterCollectionLocation(owner);
                        StorageSupport.StoreInformation(masterCollection, owner);
                    }
					IInformationCollection collection = masterCollection;
                }
<#+
        }
#>
            }

            public static void RefreshMasterCollections(IContainerOwner owner)
            {
<#+
		foreach(var masterColl in masterCollections)
        {
			string masterCollName = masterColl.name;
#>
                {
                    IInformationCollection masterCollection = <#= masterCollName #>.GetMasterCollectionInstance(owner);
                    if (masterCollection == null)
                        throw new InvalidDataException("Master collection <#= masterCollName #> missing for owner");
                    masterCollection.RefreshContent();
                    StorageSupport.StoreInformation((IInformationObject) masterCollection, owner);
                }
<#+
        }
#>
            }
		}
<#+

    }

	void GenerateInformationObject(InformationObjectType informationObject)
	{
		string semanticDomainName = CurrInstance.semanticDomainName;
		string objectName = informationObject.name;
		string informationObjectName = informationObject.name;
		CollectionForType collType = informationObject.Item as CollectionForType;
		bool isCollection = collType != null;

		InformationItemsType itemsType = informationObject.Item as InformationItemsType;
		bool containsCollection = itemsType != null && itemsType.InformationItem.Any(item => item.isCollection);

		bool provideDefaultCreate = informationObject.provideCreateMethod;
		bool isIndependentMaster = informationObject.isIndependentMaster;
		bool isProtoBuf = informationObject.serializationType == InformationObjectTypeSerializationType.ProtoBuf;
		string protoBufClassAttribute = isProtoBuf ? "[ProtoContract]" : "";
		string protoBufMemberFormat = isProtoBuf ? "[ProtoMember({0})]" : "";
		bool customIDGeneration = informationObject.AutomationDefinition != null ? informationObject.AutomationDefinition.customIDProvider : false;
#>
			[DataContract] <#= protoBufClassAttribute #>
			[Serializable]
			public partial class <#= informationObjectName #> : IInformationObject <#= isCollection ? ", IInformationCollection" : "" #>
			{
		        public static StorageSerializationType ClassStorageSerializationType { 
					get {
						return <#= GetStorageSerializationReturnValue(informationObject) #>;
					}
				}

				public <#= informationObjectName #>()
				{
					this.ID = <#= customIDGeneration ? informationObjectName + "Implementation.GetID()" : "Guid.NewGuid().ToString()" #>;
				    this.OwnerID = StorageSupport.ActiveOwnerID;
				    this.SemanticDomainName = "<#= semanticDomainName #>";
				    this.Name = "<#= objectName #>";
					UpdateRelativeLocationFromID();
				}

				public static IInformationObject[] RetrieveCollectionFromOwnerContent(IContainerOwner owner)
				{
					//string contentTypeName = ""; // SemanticDomainName + "." + Name
					string contentTypeName = "<#= semanticDomainName #>/<#= objectName #>/";
					List<IInformationObject> informationObjects = new List<IInformationObject>();
					var blobListing = StorageSupport.GetContentBlobListing(owner, contentType: contentTypeName);
					foreach(CloudBlockBlob blob in blobListing)
					{
						if (blob.GetBlobInformationType() != StorageSupport.InformationType_InformationObjectValue)
							continue;
						IInformationObject informationObject = StorageSupport.RetrieveInformation(blob.Name, typeof(<#= objectName #>), null, owner);
					    informationObject.MasterETag = informationObject.ETag;
						informationObjects.Add(informationObject);
					}
					return informationObjects.ToArray();
				}

				public void UpdateRelativeLocationFromID()
				{
					RelativeLocation = ObjectStorage.GetRelativeLocationFromID<<#= objectName #>>(ID);
				}

				IInformationObject IInformationObject.RetrieveMaster(bool initiateIfMissing, out bool initiated)
				{
					IInformationObject iObject = (IInformationObject) this;
					if(iObject.IsIndependentMaster == false)
						throw new NotSupportedException("Cannot retrieve master for non-master type: <#= informationObjectName #>");
					initiated = false;
					var owner = VirtualOwner.FigureOwner(this);
					var master = StorageSupport.RetrieveInformation(RelativeLocation, typeof(<#= informationObjectName #>), null, owner);
					if(master == null && initiateIfMissing)
					{
						StorageSupport.StoreInformation(this, owner);
						master = this;
						initiated = true;
					}
					return master;
				}


				IInformationObject IInformationObject.RetrieveMaster(bool initiateIfMissing)
				{
					bool initiated;
					IInformationObject iObject = this;
					return iObject.RetrieveMaster(initiateIfMissing, out initiated);
				}

				public void SetLocationAsOwnerContent(IContainerOwner containerOwner, string contentName)
                {
                    // RelativeLocation = StorageSupport.GetOwnerContentLocation(containerOwner, "Content/<#= semanticDomainName #>/<#= informationObjectName #>/" + contentName);
                    RelativeLocation = StorageSupport.GetOwnerContentLocation(containerOwner, "<#= semanticDomainName #>/<#= informationObjectName #>/" + contentName);
                }

				partial void DoPostStoringExecute(IContainerOwner owner);

				public void PostStoringExecute(IContainerOwner owner)
				{
					DoPostStoringExecute(owner);
				}

				partial void DoPostDeleteExecute(IContainerOwner owner);

				public void PostDeleteExecute(IContainerOwner owner)
				{
					DoPostDeleteExecute(owner);
				}


				bool IInformationObject.IsIndependentMaster { 
					get {
						return <#= isIndependentMaster ? "true" : "false"  #>;
					}
				}


<#+	
		if(containsCollection == false) {
#>
			    public void SetValuesToObjects(NameValueCollection nameValueCollection)
			    {
                    foreach(string key in nameValueCollection.AllKeys)
                    {
                        if (key.StartsWith("Root"))
                            continue;
                        int indexOfUnderscore = key.IndexOf("_");
						if (indexOfUnderscore < 0) // >
                            continue;
                        string objectID = key.Substring(0, indexOfUnderscore);
                        object targetObject = FindObjectByID(objectID);
                        if (targetObject == null)
                            continue;
                        string propertyName = key.Substring(indexOfUnderscore + 1);
                        string propertyValue = nameValueCollection[key];
                        dynamic dyn = targetObject;
                        dyn.ParsePropertyValue(propertyName, propertyValue);
                    }
			    }

			    public object FindObjectByID(string objectId)
			    {
                    if (objectId == ID)
                        return this;
			        return FindFromObjectTree(objectId);
			    }

				void IInformationObject.UpdateMasterValueTreeFromOtherInstance(IInformationObject sourceMaster)
				{
					if (sourceMaster == null)
						throw new ArgumentNullException("sourceMaster");
					if (GetType() != sourceMaster.GetType())
						throw new InvalidDataException("Type mismatch in UpdateMasterValueTree");
					IInformationObject iObject = this;
					if(iObject.IsIndependentMaster == false)
						throw new InvalidDataException("UpdateMasterValueTree called on non-master type");
					if(ID != sourceMaster.ID)
						throw new InvalidDataException("UpdateMasterValueTree is supported only on masters with same ID");
					CopyContentFrom((<#= informationObjectName #>) sourceMaster);
				}


				Dictionary<string, List<IInformationObject>> IInformationObject.CollectMasterObjects(Predicate<IInformationObject> filterOnFalse)
				{
					Dictionary<string, List<IInformationObject>> result = new Dictionary<string, List<IInformationObject>>();
					IInformationObject iObject = (IInformationObject) this;
					iObject.CollectMasterObjectsFromTree(result, filterOnFalse);
					return result;
				}
<#+ } else { #>
				void IInformationObject.UpdateMasterValueTreeFromOtherInstance(IInformationObject sourceMaster)
				{
					throw new NotImplementedException("Collection item objects do not support tree functions for now");
				}

				Dictionary<string, List<IInformationObject>> IInformationObject.CollectMasterObjects(Predicate<IInformationObject> filterOnFalse)
				{
					throw new NotImplementedException("Collection item objects do not support tree functions for now");
				}

				void IInformationObject.SetValuesToObjects(NameValueCollection nameValueCollection)
			    {
					throw new NotImplementedException("Collection item objects do not support tree functions for now");
				}

<#+ } #>

				public string SerializeToXml(bool noFormatting = false)
				{
					DataContractSerializer serializer = new DataContractSerializer(typeof(<#= informationObjectName #>));
					using (var output = new StringWriter())
					{
						using (var writer = new XmlTextWriter(output))
						{
                            if(noFormatting == false)
						        writer.Formatting = Formatting.Indented;
							serializer.WriteObject(writer, this);
						}
						return output.GetStringBuilder().ToString();
					}
				}

				public static <#= informationObjectName #> DeserializeFromXml(string xmlString)
				{
					DataContractSerializer serializer = new DataContractSerializer(typeof(<#= informationObjectName #>));
					using(StringReader reader = new StringReader(xmlString))
					{
						using (var xmlReader = new XmlTextReader(reader))
							return (<#= informationObjectName #>) serializer.ReadObject(xmlReader);
					}
            
				}

				[DataMember] <#= string.Format(protoBufMemberFormat, 2000) #>
				public string ID { get; set; }

			    [IgnoreDataMember]
                public string ETag { get; set; }

                [DataMember]
                public Guid OwnerID { get; set; }

                [DataMember]
                public string RelativeLocation { get; set; }

                [DataMember] <#= string.Format(protoBufMemberFormat, 2001) #>
                public string Name { get; set; }

                [DataMember] <#= string.Format(protoBufMemberFormat, 2002) #>
                public string SemanticDomainName { get; set; }

				[DataMember]
				public string MasterETag { get; set; }

				[DataMember]
				public string GeneratedByProcessID { get; set; }

				public void SetRelativeLocationAsMetadataTo(string masterRelativeLocation)
				{
					RelativeLocation = GetRelativeLocationAsMetadataTo(masterRelativeLocation);
				}

				public static string GetRelativeLocationAsMetadataTo(string masterRelativeLocation)
				{
					return Path.Combine("<#= semanticDomainName #>", "<#= objectName #>", masterRelativeLocation + ".metadata").Replace("\\", "/"); 
				}

				public void SetLocationRelativeToContentRoot(string referenceLocation, string sourceName)
				{
				    RelativeLocation = GetLocationRelativeToContentRoot(referenceLocation, sourceName);
				}

                public string GetLocationRelativeToContentRoot(string referenceLocation, string sourceName)
                {
                    string relativeLocation;
                    if (String.IsNullOrEmpty(sourceName))
                        sourceName = "default";
                    string contentRootLocation = StorageSupport.GetContentRootLocation(referenceLocation);
                    relativeLocation = Path.Combine(contentRootLocation, "<#= semanticDomainName #>", "<#= objectName #>", sourceName).Replace("\\", "/");
                    return relativeLocation;
                }

				static partial void CreateCustomDemo(ref <#= informationObjectName #> customDemoObject);


<#+
		if(isCollection) {
			CollectionForType collectionItem = informationObject.Item as CollectionForType;
			string contentObjectName = collectionItem.contentInformationObjectName;
			bool isContentItemMaster = IsObjectIndependentMaster(contentObjectName);

			bool isMasterCollection = collectionItem.collectionType == CollectionForTypeCollectionType.Master;
			bool isDerivedCollection = collectionItem.collectionType == CollectionForTypeCollectionType.DerivedFromMaster;
			bool isIndependentCollection = collectionItem.collectionType == CollectionForTypeCollectionType.Independent;
			string derivedMasterCollName = collectionItem.contentInformationObjectName + "Collection";

#>
				
				void IInformationObject.UpdateCollections(IInformationCollection masterInstance)
				{
<#+			if(isContentItemMaster == false) { #>
					foreach(IInformationObject item in CollectionContent)
					{
						if(item != null)
							item.UpdateCollections(masterInstance);
					}
<#+			} #>
				}



				bool IInformationCollection.IsMasterCollection {
					get {
						return <#= isMasterCollection.ToString().ToLower() #>;
					}
				}

				string IInformationCollection.GetMasterLocation()
				{
<#+			if(isMasterCollection) { #>
					var owner = VirtualOwner.FigureOwner(this);
					return GetMasterCollectionLocation(owner);
<#+			} else { #>
					throw new NotSupportedException("Master collection location only supported for master collections");
<#+			} #>
					
				}

				IInformationCollection IInformationCollection.GetMasterInstance()
				{
<#+			if(isMasterCollection) { #>
					var owner = VirtualOwner.FigureOwner(this);
					return GetMasterCollectionInstance(owner);
<#+			} else { #>
					throw new NotSupportedException("Master collection instance only supported for master collections");
<#+			} #>
					
				}


				public string GetItemDirectory()
				{
					string dummyItemLocation = ObjectStorage.GetRelativeLocationFromID<<#= contentObjectName #>>("dummy");
					string nonOwnerDirectoryLocation = StorageSupport.GetParentDirectoryTarget(dummyItemLocation);
					var owner = VirtualOwner.FigureOwner(this);
					string ownerDirectoryLocation = StorageSupport.GetOwnerContentLocation(owner, nonOwnerDirectoryLocation);
					return ownerDirectoryLocation;
				}

				public void RefreshContent()
				{
<#+
			if(isMasterCollection)
            {
#>
					// DirectoryToMaster
					string itemDirectory = GetItemDirectory();
					IInformationObject[] informationObjects = StorageSupport.RetrieveInformationObjects(itemDirectory,
																								 typeof(<#= contentObjectName #>));
                    Array.ForEach(informationObjects, io => io.MasterETag = io.ETag);
					CollectionContent.Clear();
					CollectionContent.AddRange(informationObjects.Select(obj => (<#= contentObjectName #>) obj));
            
<#+
            } else if(isDerivedCollection) {
#>
					// CollectionToCollection
					var owner = VirtualOwner.FigureOwner(this);
					var masterCollection = <#= derivedMasterCollName #>.GetMasterCollectionInstance(owner);
					this.RefreshContentFromMaster(masterCollection);
<#+
            }
#>
				}

<#+
			if(isMasterCollection)
            {
#>
				public static <#= informationObjectName #> GetMasterCollectionInstance(IContainerOwner owner)
				{
					return ObjectStorage.RetrieveFromOwnerContent<<#= informationObjectName #>>(owner, "MasterCollection");
				}
<#+
            }
#>


<#+
			if(isMasterCollection)
            {
#>
				public static string GetMasterCollectionLocation(IContainerOwner owner)
				{
					return StorageSupport.GetOwnerContentLocation(owner, "<#= semanticDomainName #>/<#= informationObjectName #>/" + "MasterCollection");
				}
<#+
            }
#>



                public void SetMediaContent(IContainerOwner containerOwner, string contentObjectID, object mediaContent)
                {
                    IInformationObject targetObject = (IInformationObject) FindObjectByID(contentObjectID);
                    if (targetObject == null)
                        return;
					if(targetObject == this)
						throw new InvalidDataException("SetMediaContent referring to self (not media container)");
                    targetObject.SetMediaContent(containerOwner, contentObjectID, mediaContent);
                }

				
		<#+ if(provideDefaultCreate) { #>

				public static <#= informationObjectName #> CreateDefault()
				{
					var result = new <#= informationObjectName #>();
					return result;
				}

				/*
				public static <#= informationObjectName #> CreateDemoDefault()
				{
					<#= informationObjectName #> customDemo = null;
					<#= informationObjectName #>.CreateCustomDemo(ref customDemo);
					if(customDemo != null)
						return customDemo;
					var result = new <#= informationObjectName #>();
					result.CollectionContent.Add(<#= contentObjectName #>.CreateDemoDefault());
					//result.CollectionContent.Add(<#= contentObjectName #>.CreateDemoDefault());
					//result.CollectionContent.Add(<#= contentObjectName #>.CreateDemoDefault());
					return result;
				}
				*/

		<#+ } #>

				[DataMember] public List<<#= contentObjectName #>> CollectionContent = new List<<#= contentObjectName #>>();
				private <#= contentObjectName #>[] _unmodified_CollectionContent;

				[DataMember] public bool IsCollectionFiltered;
				private bool _unmodified_IsCollectionFiltered;
				
				[DataMember] public List<string> OrderFilterIDList = new List<string>();
				private string[] _unmodified_OrderFilterIDList;

				public string SelectedIDCommaSeparated
				{
					get
					{
						string[] sourceArray;
						if (OrderFilterIDList != null)
							sourceArray = OrderFilterIDList.ToArray();
						else
							sourceArray = CollectionContent.Select(item => item.ID).ToArray();
						return String.Join(",", sourceArray);
					}
					set 
					{
						if (value == null)
							return;
						string[] valueArray = value.Split(',');
						OrderFilterIDList = new List<string>();
						OrderFilterIDList.AddRange(valueArray);
						OrderFilterIDList.RemoveAll(item => CollectionContent.Any(colItem => colItem.ID == item) == false);
					}
				}

				public <#= contentObjectName #>[] GetIDSelectedArray()
				{
					if (IsCollectionFiltered == false || this.OrderFilterIDList == null)
						return CollectionContent.ToArray();
					return
						this.OrderFilterIDList.Select(id => CollectionContent.FirstOrDefault(item => item.ID == id)).Where(item => item != null).ToArray();
				}

				public void RefreshOrderAndFilterListFromContent()
                {
                    if (OrderFilterIDList == null)
                        return;
                    OrderFilterIDList.RemoveAll(item => CollectionContent.Any(colItem => colItem.ID == item) == false);
                }

				public void ParsePropertyValue(string propertyName, string propertyValue)
				{
					switch(propertyName)
					{
						case "SelectedIDCommaSeparated":
							SelectedIDCommaSeparated = propertyValue;
							break;
						case "IsCollectionFiltered":
							IsCollectionFiltered = bool.Parse(propertyValue);
							break;
						default:
							throw new NotSupportedException("No ParsePropertyValue supported for property: " + propertyName);
					}
				}


				void IInformationObject.ReplaceObjectInTree(IInformationObject replacingObject)
				{
					for(int i = 0; i < CollectionContent.Count; i++) // >
					{
						if(CollectionContent[i].ID == replacingObject.ID)
							CollectionContent[i] = (<#= contentObjectName #> )replacingObject;
						else { // Cannot have circular reference, so can be in else branch
							IInformationObject iObject = CollectionContent[i];
							iObject.ReplaceObjectInTree(replacingObject);
						}
					}
				}

				
				bool IInformationObject.IsInstanceTreeModified {
					get {
						bool collectionModified = CollectionContent.SequenceEqual(_unmodified_CollectionContent) == false;
						if(collectionModified)
							return true;
						//if((OrderFilterIDList == null && _unmodified_OrderFilterIDList != null) || _unmodified_OrderFilterIDList
						if(IsCollectionFiltered != _unmodified_IsCollectionFiltered)
							return true;
<#+
	if(isContentItemMaster == false)
    {
#>
						// For non-master content
						foreach(IInformationObject item in CollectionContent)
						{
							bool itemTreeModified = item.IsInstanceTreeModified;
							if(itemTreeModified)
								return true;
						}
							
<#+
    }
#>
						return false;
					}
				}
				void IInformationObject.SetInstanceTreeValuesAsUnmodified()
				{
					_unmodified_CollectionContent = CollectionContent.ToArray();
					_unmodified_IsCollectionFiltered = IsCollectionFiltered;
					if(OrderFilterIDList == null)
						_unmodified_OrderFilterIDList = null;
					else
						_unmodified_OrderFilterIDList = OrderFilterIDList.ToArray();
					foreach(IInformationObject iObject in CollectionContent)
						iObject.SetInstanceTreeValuesAsUnmodified();
				}

				private void CopyContentFrom(<#= informationObjectName #> sourceObject)
				{
					CollectionContent = sourceObject.CollectionContent;
					_unmodified_CollectionContent = sourceObject._unmodified_CollectionContent;
				}
				
				private object FindFromObjectTree(string objectId)
				{
					foreach(var item in CollectionContent)
					{
						object result = item.FindObjectByID(objectId);
						if(result != null)
							return result;
					}
					return null;
				}

				void IInformationObject.FindObjectsFromTree(List<IInformationObject> result, Predicate<IInformationObject> filterOnFalse, bool searchWithinCurrentMasterOnly)
				{
					if(filterOnFalse(this))
						result.Add(this);
<#+
	if(isContentItemMaster == false)
    {

#>
					foreach(IInformationObject iObject in CollectionContent)
						iObject.FindObjectsFromTree(result, filterOnFalse, searchWithinCurrentMasterOnly);
<#+
    } else { // Content item is master, thus we need to filter
#>
					if(searchWithinCurrentMasterOnly == false) {
						foreach(IInformationObject iObject in CollectionContent)
							iObject.FindObjectsFromTree(result, filterOnFalse, searchWithinCurrentMasterOnly);
					}
<#+
    }
#>
				}


				void IInformationObject.CollectMasterObjectsFromTree(Dictionary<string, List<IInformationObject>> result, Predicate<IInformationObject> filterOnFalse)
				{
					IInformationObject iObject = (IInformationObject) this;
					if(iObject.IsIndependentMaster)
					{
						bool doAdd = true;
						if(filterOnFalse != null)
							doAdd = filterOnFalse(iObject);
						if(doAdd) {
							string key = iObject.ID;
							List<IInformationObject> existingValue;
							bool keyFound = result.TryGetValue(key, out existingValue);
							if(keyFound == false) {
								existingValue = new List<IInformationObject>();
								result.Add(key, existingValue);
							}
							existingValue.Add(iObject);
						}
					}
					foreach(IInformationObject item in CollectionContent)
					{
						if(item != null)
							item.CollectMasterObjectsFromTree(result, filterOnFalse);
					}
				}


<#+
		} else {
			GenerateInformationObjectChoice(informationObject, informationObjectName, informationObject.Item);
		}
#>			
			}
<#+
	}

	void GenerateInformationObjectChoice(InformationObjectType informationObject, string informationObjectName, object contentItem)
	{
		InformationItemsType informationItems = contentItem as InformationItemsType;
		InformationObjectContentType objectContent = contentItem as InformationObjectContentType;
		if(informationItems != null) {
			GenerateDefaultCreateForItems(informationObject, informationObjectName, informationItems.InformationItem);
			GenerateInformationItemsMethods(informationObjectName, informationItems.InformationItem);
			GenerateInformationItems(informationItems.InformationItem);
		}
		if(objectContent != null)
			GenerateInformationObjectContent(informationObject, informationObjectName, objectContent);
	}

	void GenerateInformationObjectContent(InformationObjectType informationObject, string informationObjectName, InformationObjectContentType objectContent)
	{
#>
				// Properties to map to handle the file: <#= objectContent.originalFileName #>.<#= objectContent.fileExtension #>
				// TODO: Handle object collections
				private object FindFromObjectTree(string objectId)
				{
					return null;
				}

				void IInformationObject.UpdateCollections(IInformationCollection masterInstance)
				{
				}


				void IInformationObject.FindObjectsFromTree(List<IInformationObject> result, Predicate<IInformationObject> filterOnFalse, bool searchWithinCurrentMasterOnly)
				{
					if(filterOnFalse(this))
						result.Add(this);
				}

				bool IInformationObject.IsInstanceTreeModified {
					get {
						// Currently is always false
						return false;
					}
				}
				void IInformationObject.SetInstanceTreeValuesAsUnmodified()
				{
					// Reflected to IsModified above, no action right now
				}

				void IInformationObject.ReplaceObjectInTree(IInformationObject replacingObject)
				{
					// Cannot replace self, doesn't contain subitems, nothing to do
				}

				void IInformationObject.CollectMasterObjectsFromTree(Dictionary<string, List<IInformationObject>> result, Predicate<IInformationObject> filterOnFalse)
				{
					IInformationObject iObject = (IInformationObject) this;
					if(iObject.IsIndependentMaster)
					{
						if(filterOnFalse == null || filterOnFalse(iObject)) 
						{
							string key = iObject.ID;
							List<IInformationObject> existingValue;
							bool keyFound = result.TryGetValue(key, out existingValue);
							if(keyFound == false) {
								existingValue = new List<IInformationObject>();
								result.Add(key, existingValue);
							}
							existingValue.Add(iObject);
						}
					}
				}

				private void CopyContentFrom(<#= informationObjectName #> sourceObject)
				{
					throw new NotImplementedException("Media masters are not currently supported");
				}


<#+		if(informationObject.provideCreateMethod) {  #>
				public static <#= informationObjectName #> CreateDefault()
				{
					var result = new <#= informationObjectName #>();
					return result;
				}

				public static <#= informationObjectName #> CreateDemoDefault()
				{
					<#= informationObjectName #> customDemo = null;
					<#= informationObjectName #>.CreateCustomDemo(ref customDemo);
					if(customDemo != null)
						return customDemo;
					var result = new <#= informationObjectName #>();
					return result;
				}


<#+
		}
	}

	void GenerateInformationItemsMethods(string informationObjectName, InformationItemType[] informationItems)
	{
		InformationItemType[] informationObjects = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName) == false).ToArray();
		InformationItemType[] nonMasterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == false).ToArray();
		InformationItemType[] masterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == true).ToArray();
		InformationItemType[] primitiveItems = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName)).ToArray();
		bool containsCollection = informationItems.Any(item => item.isCollection);
		string domainName = CurrentAbstraction.InstanceOfTheBall.semanticDomainName;
		if(containsCollection == false) {
#>

				void IInformationObject.UpdateCollections(IInformationCollection masterInstance)
				{
					//Type collType = masterInstance.GetType();
					//string typeName = collType.Name;
<#+
			foreach(InformationItemType informationItem in nonMasterInformationObjects)
			{
				//var childItem = GetInformationObjectByName(informationItem.informationObjectName);
				string itemName = informationItem.name;
				string itemTypeName = informationItem.informationObjectName;
				bool isMasterCollItem = IsItemMasterCollection(informationItem);
				if(isMasterCollItem) {
#>
					if(masterInstance is <#= itemTypeName #>) {
						<#= domainName #>.CollectionUpdateImplementation.Update_<#= informationObjectName #>_<#= itemName #>(this, localCollection:<#= itemName #>, masterCollection:(<#= itemTypeName #>) masterInstance);
					} else if(<#= itemName  #> != null) {
						((IInformationObject) <#= itemName #>).UpdateCollections(masterInstance);
					}
<#+				} else { #>
					if(<#= itemName  #> != null) {
						((IInformationObject) <#= itemName #>).UpdateCollections(masterInstance);
					}

<#+				} #>
<#+			} #>
				}

                public void SetMediaContent(IContainerOwner containerOwner, string contentObjectID, object mediaContent)
                {
                    IInformationObject targetObject = (IInformationObject) FindObjectByID(contentObjectID);
                    if (targetObject == null)
                        return;
					if(targetObject == this)
						throw new InvalidDataException("SetMediaContent referring to self (not media container)");
                    targetObject.SetMediaContent(containerOwner, contentObjectID, mediaContent);
                }
<#+		} #>


				void IInformationObject.FindObjectsFromTree(List<IInformationObject> result, Predicate<IInformationObject> filterOnFalse, bool searchWithinCurrentMasterOnly)
				{
<#+
		if(containsCollection) {
#>
					// Remove exception if basic functionality starts to have issues
					//throw new NotImplementedException("Item level collections do not support object tree operations right now");
					if(filterOnFalse(this))
						result.Add(this);
<#+
        } else {
#>
					if(filterOnFalse(this))
						result.Add(this);
<#+
			foreach(InformationItemType informationItem in nonMasterInformationObjects)
			{
#>
					{ // Scoping block for variable name reusability
						IInformationObject item = <#= informationItem.name #>;
						if(item != null)
						{
							item.FindObjectsFromTree(result, filterOnFalse, searchWithinCurrentMasterOnly);
						}
					} // Scoping block end

<#+ 
			}
#>
					if(searchWithinCurrentMasterOnly == false)
					{
<#+
			foreach(InformationItemType informationItem in masterInformationObjects)
			{
#>
						{
							IInformationObject item = <#= informationItem.name #>;
							if(item != null)
							{
								item.FindObjectsFromTree(result, filterOnFalse, searchWithinCurrentMasterOnly);
							}
						}
<#+ 
			}
#>
					}					
<#+
        }
#>
				}

<#+		
		if(containsCollection == false) 
        {
#>
				private object FindFromObjectTree(string objectId)
				{
<#+
			foreach(InformationItemType informationItem in informationObjects)
			{
#>
					{
						var item = <#= informationItem.name #>;
						if(item != null)
						{
							object result = item.FindObjectByID(objectId);
							if(result != null)
								return result;
						}
					}
<#+ 
			}
#>
					return null;
				}
				void IInformationObject.CollectMasterObjectsFromTree(Dictionary<string, List<IInformationObject>> result, Predicate<IInformationObject> filterOnFalse)
				{
					IInformationObject iObject = (IInformationObject) this;
					if(iObject.IsIndependentMaster)
					{
						if(filterOnFalse == null || filterOnFalse(iObject)) 
						{
							string key = iObject.ID;
							List<IInformationObject> existingValue;
							bool keyFound = result.TryGetValue(key, out existingValue);
							if(keyFound == false) {
								existingValue = new List<IInformationObject>();
								result.Add(key, existingValue);
							}
							existingValue.Add(iObject);
						}
					}
<#+
			foreach(InformationItemType informationItem in informationObjects)
			{
#>
					{
						var item = (IInformationObject) <#= informationItem.name #>;
						if(item != null)
							item.CollectMasterObjectsFromTree(result, filterOnFalse);
					}
<#+ 
			}
        } else {
#>
				void IInformationObject.CollectMasterObjectsFromTree(Dictionary<string, List<IInformationObject>> result, Predicate<IInformationObject> filterOnFalse)
				{
					throw new NotImplementedException("Object tree support not implemented for item level collection objects");

<#+		} #>

				}

<#+
		if(containsCollection) {
#>
			
                void IInformationObject.SetMediaContent(IContainerOwner containerOwner, string contentObjectID, object mediaContent)
                {
					// Remove exception if some basic functionality is broken due to it
					throw new NotImplementedException("Collection items do not support instance tree queries as of now");
				}
	

				bool IInformationObject.IsInstanceTreeModified {
					get { 
						// Remove exception if some basic functionality is broken due to it
						throw new NotImplementedException("Collection items do not support instance tree queries as of now");
					}
				}
				void IInformationObject.ReplaceObjectInTree(IInformationObject replacingObject)
				{
					// Remove exception if some basic functionality is broken due to it
					throw new NotImplementedException("Collection items do not support instance tree queries as of now");
				}

				void IInformationObject.SetInstanceTreeValuesAsUnmodified()
				{
					// Remove exception if some basic functionality is broken due to it
					//throw new NotImplementedException("Collection items do not support instance tree queries as of now");
				}

				void IInformationObject.UpdateCollections(IInformationCollection masterInstance)
				{
					// Remove exception if some basic functionality is broken due to it
					throw new NotImplementedException("Collection items do not support instance tree queries as of now");
				}

<#+
        } else {
#>
				bool IInformationObject.IsInstanceTreeModified {
					get { 

<#+
			foreach(var item in informationItems)
			{
		
#>
						if(<#= item.name #> != _unmodified_<#= item.name #>)
							return true;
<#+
			}
			foreach(var nonMasterItem in nonMasterInformationObjects)
			{
#>
						{
							IInformationObject item = (IInformationObject) <#= nonMasterItem.name #>;
							if(item != null) 
							{
								bool isItemTreeModified = item.IsInstanceTreeModified;
								if(isItemTreeModified)
									return true;
							}
						}
<#+			}
#>				
						return false;
					}
				}

				void IInformationObject.ReplaceObjectInTree(IInformationObject replacingObject)
				{
<#+
			foreach(InformationItemType item in informationObjects)
			{

#>
					if(<#= item.name #> != null) {
						if(<#= item.name #>.ID == replacingObject.ID)
							<#= item.name #> = (<#= item.informationObjectName #>) replacingObject;
						else {
							IInformationObject iObject = <#= item.name #>;
							iObject.ReplaceObjectInTree(replacingObject);
						}
					}
<#+
			}
#>
				}


				private void CopyContentFrom(<#= informationObjectName #> sourceObject)
				{
<#+
			foreach(var item in informationItems)
			{
#>
					<#= item.name #> = sourceObject.<#= item.name #>;
<#+
			}
#>
				}
				


				void IInformationObject.SetInstanceTreeValuesAsUnmodified()
				{
<#+
			foreach(var item in primitiveItems)
			{
			
#>
					_unmodified_<#= item.name #> = <#= item.name #>;
<#+
			}
#>				
<#+
			foreach(var item in informationObjects)
			{
			
#>
					_unmodified_<#= item.name #> = <#= item.name #>;
					if(<#= item.name #> != null)
						((IInformationObject) <#= item.name #>).SetInstanceTreeValuesAsUnmodified();

<#+
			}
        
#>				
				}

<#+
        }
#>

				public void ParsePropertyValue(string propertyName, string value)
				{
					switch (propertyName)
					{
<#+
		foreach(InformationItemType item in primitiveItems)
		{
			string physicalType = GetPlatformDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
			if(physicalType == "byte[]")
				continue;
			bool isStringType = physicalType == "string";
			string parseExpression = isStringType ? "value" : physicalType + ".Parse(value)";
			if(item.isCollection) {
#>
						case "<#= item.name #>":
							throw new NotImplementedException("Parsing collection types is not implemented for item collections");
							break;
<#+
            } else {
#>
						case "<#= item.name #>":
							<#= item.name #> = <#= parseExpression #>;
							break;
<#+
            }
		}
#>
						default:
							throw new InvalidDataException("Primitive parseable data type property not found: " + propertyName);
					}
	        }
<#+
	}
	
	void GenerateDefaultCreateForItems(InformationObjectType informationObject, string informationObjectName, InformationItemType[] informationItems)
	{
		if(informationObject.provideCreateMethod == false)
			return;
#>

				public static <#= informationObjectName #> CreateDefault()
				{
					var result = new <#= informationObjectName #>();
<#+
		foreach(var informationItem in informationItems)
		{
			if(informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject)
			{
#>
					result.<#= informationItem.name #> = <#= informationItem.informationObjectName #>.CreateDefault();
<#+
			}
		}
#>
					return result;
				}
				/*
				public static <#= informationObjectName #> CreateDemoDefault()
				{
					<#= informationObjectName #> customDemo = null;
					<#= informationObjectName #>.CreateCustomDemo(ref customDemo);
					if(customDemo != null)
						return customDemo;
					var result = new <#= informationObjectName #>();
<#+
		foreach(var informationItem in informationItems)
		{
			if(informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject)
			{
#>
					result.<#= informationItem.name #> = <#= informationItem.informationObjectName #>.CreateDemoDefault();
<#+
			}
			if(informationItem.logicalDataType == InformationItemTypeLogicalDataType.Text_Short ||
				informationItem.logicalDataType == InformationItemTypeLogicalDataType.Text_Long)
			{
				string placeHolderText = informationObject.name + "." + informationItem.name;
				if(informationItem.logicalDataType == InformationItemTypeLogicalDataType.Text_Long)
					placeHolderText = string.Format("{0}{1}{0}{1}{0}{1}{0}{1}{0}{1}", placeHolderText, Environment.NewLine);

#>
					result.<#= informationItem.name #> = @"<#= placeHolderText #>";

<#+
			}
		}
#>				
					return result;
				}
				*/
<#+
	}

	void GenerateInformationItems(InformationItemType[] informationItems)
	{
		foreach(var item in informationItems)
		{
			string dataType = GetPlatformDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
			bool isCollection = item.isCollection;
			int protoBufTagNumber = item.fieldOrderNumber;
			string protoBufAttribute = protoBufTagNumber > 0 ? string.Format("[ProtoMember({0})]", protoBufTagNumber) : "";
			if(isCollection)
            {
#>
			[DataMember] <#= protoBufAttribute #>
			public List< <#= dataType #> > <#= item.name #> = new List< <#= dataType #> >();
<#+
            } else {
#>
			[DataMember] <#= protoBufAttribute #>
			public <#= dataType #> <#= item.name #> { get; set; }
			private <#= dataType #> _unmodified_<#= item.name #>;
<#+
            }
		}
	}

	string GetPlatformDataTypeFromLogical(InformationItemTypeLogicalDataType logicalDataType, string informationObjectName)
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
				return "double";
			//case InformationItemTypeLogicalDataType.Number_CustomFormat:
			//	return "string";
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "double";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "long";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
			case InformationItemTypeLogicalDataType.ObjectLink:
				return "string";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InformationItemTypeLogicalDataType.InformationObject:
				return informationObjectName;
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
	}

	string GetStorageSerializationReturnValue(InformationObjectType iObj)
    {
		return "StorageSerializationType." + iObj.serializationType.ToString();
    }

	InformationObjectType[] GetMasterCollections(InstanceOfTheBallType instance)
    {
		if(instance.InformationModel == null)
			return new InformationObjectType[0];
		var results = instance.InformationModel.Where(obj => {
				CollectionForType coll = obj.Item as CollectionForType;
				return coll != null && coll.collectionType == CollectionForTypeCollectionType.Master;
			}).ToArray();
		return results;
    }

	InformationObjectType GetMasterCollectionByName(InstanceOfTheBallType instance, string name)
    {
		return GetMasterCollections(instance).FirstOrDefault(coll => coll.name == name);
    }

	InformationObjectType[] GetDerivedFromMasterCollections(InstanceOfTheBallType instance)
    {
		var results = instance.InformationModel.Where(obj => {
				CollectionForType coll = obj.Item as CollectionForType;
				return coll != null && coll.collectionType == CollectionForTypeCollectionType.DerivedFromMaster;
			}).ToArray();
		return results;
    }

	InformationObjectType GetMasterCollectionForItem(InstanceOfTheBallType instance, string collItemName)
    {
		var result = instance.InformationModel.FirstOrDefault(obj => {
				CollectionForType coll = obj.Item as CollectionForType;
				return coll != null && coll.collectionType == CollectionForTypeCollectionType.Master && coll.contentInformationObjectName == collItemName;
			});
		return result;
    }


#>