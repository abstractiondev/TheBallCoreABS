<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>
<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + ".designer.cs";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InstanceOfTheBallType CurrInstance;
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}
	
	void GenerateAbstraction(TheBallCoreAbstractionType abstraction)
	{
		InstanceOfTheBallType instance = abstraction.InstanceOfTheBall;
		CurrInstance = instance;
		GenerateInstance(instance);
	}	

	void GenerateInstance(InstanceOfTheBallType instance)
	{
#>
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Runtime.Serialization;
using Microsoft.WindowsAzure.StorageClient;
using TheBall;

<#+
		BeginNamespace(instance.semanticDomainName);
#>
    public interface IInformationObject
    {
        Guid OwnerID { get; set; }
        string ID { get; set; }
        string ETag { get; set;  }
        string RelativeLocation { get; set; }
        string SemanticDomainName { get; set; }
        string Name { get; set; }
		void InitializeDefaultSubscribers(IContainerOwner owner);
		void SetValuesToObjects(NameValueCollection form);
		void PostStoringExecute(IContainerOwner owner);
		void PostDeleteExecute(IContainerOwner owner);
		void SetLocationRelativeToRoot(string rootLocation);
    }

<#+
		foreach(var informationObject in instance.InformationModel)
			GenerateInformationObject(informationObject);

		EndBlock(); // namespace
#>

<#+
	}
	
	void GenerateInformationObject(InformationObjectType informationObject)
	{
		string semanticDomainName = CurrInstance.semanticDomainName;
		string objectName = informationObject.name;
		string informationObjectName = informationObject.name;
		bool isCollection = informationObject.Item is CollectionForType;
		bool provideDefaultCreate = informationObject.provideCreateMethod;
#>
			[DataContract]
			public partial class <#= informationObjectName #> : IInformationObject
			{
				public <#= informationObjectName #>()
				{
					this.ID = Guid.NewGuid().ToString();
				    this.OwnerID = StorageSupport.ActiveOwnerID;
				    this.SemanticDomainName = "<#= semanticDomainName #>";
				    this.Name = "<#= objectName #>";
					RelativeLocation = GetRelativeLocationFromID(ID);
				}

                public static string GetRelativeLocationFromID(string id)
                {
                    return Path.Combine("<#= semanticDomainName #>", "<#= objectName #>", id).Replace("\\", "/");
                }

				public void UpdateRelativeLocationFromID()
				{
					RelativeLocation = GetRelativeLocationFromID(ID);
				}

				public static <#= informationObjectName #> RetrieveFromDefaultLocation(string id, IContainerOwner owner = null)
				{
					string relativeLocation = GetRelativeLocationFromID(id);
					return Retrieve<#= informationObjectName #>(relativeLocation, owner);
				}


                public static <#= informationObjectName #> Retrieve<#= informationObjectName #>(string relativeLocation, IContainerOwner owner = null)
                {
                    var result = (<#= informationObjectName #>) StorageSupport.RetrieveInformation(relativeLocation, typeof(<#= informationObjectName #>), null, owner);
                    return result;
                }

				partial void DoInitializeDefaultSubscribers(IContainerOwner owner);

			    public void InitializeDefaultSubscribers(IContainerOwner owner)
			    {
					DoInitializeDefaultSubscribers(owner);
			    }

				partial void DoPostStoringExecute(IContainerOwner owner);

				public void PostStoringExecute(IContainerOwner owner)
				{
					DoPostStoringExecute(owner);
				}

				partial void DoPostDeleteExecute(IContainerOwner owner);

				public void PostDeleteExecute(IContainerOwner owner)
				{
					DoPostDeleteExecute(owner);
				}


			    public void SetValuesToObjects(NameValueCollection nameValueCollection)
			    {
                    foreach(string key in nameValueCollection.AllKeys)
                    {
                        if (key.StartsWith("RootObject"))
                            continue;
                        int indexOfUnderscore = key.IndexOf("_");
                        string objectID = key.Substring(0, indexOfUnderscore);
                        string propertyName = key.Substring(indexOfUnderscore + 1);
                        string propertyValue = nameValueCollection[key];
                        object targetObject = FindObjectByID(objectID);
                        dynamic dyn = targetObject;
                        dyn.ParsePropertyValue(propertyName, propertyValue);
                    }
			    }


			    public object FindObjectByID(string objectId)
			    {
                    if (objectId == ID)
                        return this;
			        return FindFromObjectTree(objectId);
			    }

				public string SerializeToXml(bool noFormatting = false)
				{
					DataContractSerializer serializer = new DataContractSerializer(typeof(<#= informationObjectName #>));
					using (var output = new StringWriter())
					{
						using (var writer = new XmlTextWriter(output))
						{
                            if(noFormatting == false)
						        writer.Formatting = Formatting.Indented;
							serializer.WriteObject(writer, this);
						}
						return output.GetStringBuilder().ToString();
					}
				}

				public static <#= informationObjectName #> DeserializeFromXml(string xmlString)
				{
					DataContractSerializer serializer = new DataContractSerializer(typeof(<#= informationObjectName #>));
					using(StringReader reader = new StringReader(xmlString))
					{
						using (var xmlReader = new XmlTextReader(reader))
							return (<#= informationObjectName #>) serializer.ReadObject(xmlReader);
					}
            
				}

				[DataMember]
				public string ID { get; set; }

			    [IgnoreDataMember]
                public string ETag { get; set; }

                [DataMember]
                public Guid OwnerID { get; set; }

                [DataMember]
                public string RelativeLocation { get; set; }

                [DataMember]
                public string Name { get; set; }

                [DataMember]
                public string SemanticDomainName { get; set; }

				public void SetRelativeLocationAsMetadataTo(IInformationObject masterObject)
				{
					RelativeLocation = GetRelativeLocationAsMetadataTo(masterObject);
				}

				public static string GetRelativeLocationAsMetadataTo(IInformationObject masterObject)
				{
					return Path.Combine("<#= semanticDomainName #>", "<#= objectName #>", masterObject.RelativeLocation).Replace("\\", "/"); 
				}

				public void SetLocationRelativeToRoot(string masterLocation)
				{
					RelativeLocation = Path.Combine(masterLocation, "<#= semanticDomainName #>", "<#= objectName #>", ID).Replace("\\", "/");
				}


<#+
		if(isCollection) {
			CollectionForType collectionItem = informationObject.Item as CollectionForType;
			string contentObjectName = collectionItem.contentInformationObjectName;
#>

				
		<#+ if(provideDefaultCreate) { #>

				public static <#= informationObjectName #> CreateDefault()
				{
					return new <#= informationObjectName #>();
				}
		<#+ } #>

				[DataMember] public List<<#= contentObjectName #>> CollectionContent = new List<<#= contentObjectName #>>();

				private object FindFromObjectTree(string objectId)
				{
					foreach(var item in CollectionContent)
					{
						object result = item.FindObjectByID(objectId);
						if(result != null)
							return result;
					}
					return null;
				}


<#+
		} else {
			GenerateInformationObjectChoice(informationObject, informationObjectName, informationObject.Item);
		}
#>			
			}
<#+
	}

	void GenerateInformationObjectChoice(InformationObjectType informationObject, string informationObjectName, object contentItem)
	{
		InformationItemsType informationItems = contentItem as InformationItemsType;
		InformationObjectContentType objectContent = contentItem as InformationObjectContentType;
		if(informationItems != null) {
			GenerateDefaultCreateForItems(informationObject, informationObjectName, informationItems.InformationItem);
			GenerateInformationItemsMethods(informationItems.InformationItem);
			GenerateInformationItems(informationItems.InformationItem);
		}
		if(objectContent != null)
			GenerateInformationObjectContent(informationObject, informationObjectName, objectContent);
	}

	void GenerateInformationObjectContent(InformationObjectType informationObject, string informationObjectName, InformationObjectContentType objectContent)
	{
#>
				// Properties to map to handle the file: <#= objectContent.originalFileName #>.<#= objectContent.fileExtension #>
				// TODO: Handle object collections
				private object FindFromObjectTree(string objectId)
				{
					return null;
				}
<#+		if(informationObject.provideCreateMethod) {  #>
				public static <#= informationObjectName #> CreateDefault()
				{
					var result = new <#= informationObjectName #>();
					return result;
				}

<#+
		}
	}

	void GenerateInformationItemsMethods(InformationItemType[] informationItems)
	{
		InformationItemType[] informationObjects = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName) == false).ToArray();
		InformationItemType[] primitiveItems = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName)).ToArray();
#>
				private object FindFromObjectTree(string objectId)
				{
<#+
		foreach(InformationItemType informationItem in informationObjects)
		{
#>
					{
						var item = <#= informationItem.name #>;
						object result = item.FindObjectByID(objectId);
						if(result != null)
							return result;
					}
<#+ 
		}
#>
					return null;
				}

				public void ParsePropertyValue(string propertyName, string value)
				{
					switch (propertyName)
					{
<#+
		foreach(InformationItemType item in primitiveItems)
		{
			string physicalType = GetPhysicalDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
			if(physicalType == "byte[]")
				continue;
			bool isStringType = physicalType == "string";
			string parseExpression = isStringType ? "value" : physicalType + ".Parse(value)";
#>
						case "<#= item.name #>":
							<#= item.name #> = <#= parseExpression #>;
							break;
<#+
		}
#>
						default:
							throw new InvalidDataException("Primitive parseable data type property not found: " + propertyName);
					}
	        }
<#+
	}
	
	void GenerateDefaultCreateForItems(InformationObjectType informationObject, string informationObjectName, InformationItemType[] informationItems)
	{
		if(informationObject.provideCreateMethod == false)
			return;
#>
				public static <#= informationObjectName #> CreateDefault()
				{
					var result = new <#= informationObjectName #>();
<#+
		foreach(var informationItem in informationItems)
		{
			if(informationItem.logicalDataType != InformationItemTypeLogicalDataType.InformationObject)
				continue;
#>
					result.<#= informationItem.name #> = <#= informationItem.informationObjectName #>.CreateDefault();
<#+
		}
#>				
					return result;
				}
<#+
	}

	void GenerateInformationItems(InformationItemType[] informationItems)
	{
		foreach(var item in informationItems)
		{
			string dataType = GetPhysicalDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
#>
			[DataMember]
			public <#= dataType #> <#= item.name #> { get; set; }
<#+
		}
	}

	string GetPhysicalDataTypeFromLogical(InformationItemTypeLogicalDataType logicalDataType, string informationObjectName)
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
				return "double";
			//case InformationItemTypeLogicalDataType.Number_CustomFormat:
			//	return "string";
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "double";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "long";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
				return "string";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InformationItemTypeLogicalDataType.InformationObject:
				return informationObjectName;
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
	}
#>