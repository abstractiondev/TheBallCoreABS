<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>
<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			if(abs.InstanceOfTheBall.DigitalInterface == null || abs.InstanceOfTheBall.DigitalInterface.InterfaceModel == null)
				continue;
			InstanceOfTheBallType instance = abs.InstanceOfTheBall;
			CurrInstance = instance;
			foreach(var interfaceView in abs.InstanceOfTheBall.DigitalInterface.InterfaceViews)
            {
				CurrView = interfaceView;
				this.GenerationEnvironment.Clear();
				string content = TransformText();
				string outputFileName = CurrInstance.semanticDomainName + "." + CurrView.name + ".admgen.dust";
				//string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + ".admgen.ts";
				result.Add(Tuple.Create(outputFileName, content));
            }
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InterfaceViewType CurrView;
	InstanceOfTheBallType CurrInstance;
	
	void GenerateRoot()
	{
		if(CurrView == null)
			return;
		GenerateInterfaceView(CurrView);
	}

	string GetTSDataType(InterfaceItemTypeLogicalDataType logicalDataType)
    {
		switch (logicalDataType)
		{
			case InterfaceItemTypeLogicalDataType.Text_Long:
			case InterfaceItemTypeLogicalDataType.Text_Short:
				return "string";
			case InterfaceItemTypeLogicalDataType.Time_Date:
			case InterfaceItemTypeLogicalDataType.Time_Time:
			case InterfaceItemTypeLogicalDataType.Time_DateTime:
				return "Date";
			case InterfaceItemTypeLogicalDataType.Number:
				return "number";
			default:
				throw new NotSupportedException("Logical data type not supported: " + logicalDataType);
		}
    }

	InterfaceObjectType GetInterfaceObjectByName(string interfaceObjectName)
    {
		var result = CurrInstance.DigitalInterface.InterfaceModel.FirstOrDefault(candidate => candidate.name == interfaceObjectName);
		if(result == null)
			throw new ArgumentException("Interface object not found with name: " + interfaceObjectName);
		return result;
    }

	void GenerateInterfaceView(InterfaceViewType iView)
    {
		string viewName = iView.name;
		bool autoRecurseSubfields = iView.autoRecurseSubViews;

#>

<div>
<#+ GenerateViewItems(iView.Items); #>

</div>


<#+
    }

	void GenerateViewItems(object[] interfaceItems)
    {
		foreach (var item in interfaceItems)
		{
			string itemName;
			string dataType;
			ViewFieldType vField = item as ViewFieldType;
			SubViewType subView = item as SubViewType;
			dynamic dynItem = item;
			string collectionPostFix = dynItem.isCollection ? "[]" : "";
			if(vField != null) {
				GenerateViewField(vField);
            } else if(subView != null) {
				GenerateSubView(subView);
            } else
				throw new NotSupportedException("InterfaceItem type not supported: " + item.GetType().Name);
        }

    }

	void GenerateViewField(ViewFieldType vField)
    {
		string classNames = vField.classNames;
		string modelFieldName = vField.viewItemPath;
		string modelFieldListName = modelFieldName + "_AllowedValues";
		string controlFormatString = null;
		bool editable = vField.displayMode == ViewFieldTypeDisplayMode.Editable;
		switch(vField.fieldType)
        {
			case ViewFieldTypeFieldType.CheckBox:
				//if(editable)
					controlFormatString = "<input type=\"checkbox\" data-bind=\"checked: {0}\" />";
				//else 

				break;
			case ViewFieldTypeFieldType.DropdownList:
				controlFormatString = "<select data-bind=\"value: {0}, options: {1}\" />";
				break;
			case ViewFieldTypeFieldType.MultiselectList:
				controlFormatString = "<select multiple=\"multiple\" data-bind=\"selectedOptions: {0}, options: {1}\" />";
				break;
			case ViewFieldTypeFieldType.RadioButton:
				break;
			case ViewFieldTypeFieldType.TextBox:
				controlFormatString = "<input data-bind=\"value: {0}\" />";
				break;
			case ViewFieldTypeFieldType.TextBoxHiddenChars:
				controlFormatString = "<input type=\"password\" data-bind=\"value: {0}\" />";
				break;
			case ViewFieldTypeFieldType.TextBoxMultiline:
				controlFormatString = "<textarea data-bind=\"value: {0}\"></textarea>";
				break;
			default:
				throw new NotSupportedException("Field type not supported in view field generator: " + vField.ToString());
        }
		string controlString = string.Format(controlFormatString, modelFieldName, modelFieldListName);

    }

	void GenerateSubView(SubViewType subView)
    {
    }
	
#>