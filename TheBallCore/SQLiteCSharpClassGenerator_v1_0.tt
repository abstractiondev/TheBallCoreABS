<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>

<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			InstanceRelationsTableList.Clear();
			this.GenerationEnvironment.Clear();
			ItemTypesToIgnore.Clear();
			ItemTypesToIgnore.Add("MediaContent");
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + "_SQLite.designer.cs";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InstanceOfTheBallType CurrInstance;

	List<string> ItemTypesToIgnore = new List<string>();
	List< Tuple<string, string, string> > InstanceRelationsTableList = new List< Tuple<string, string, string> >();
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}

	void GenerateAbstraction(TheBallCoreAbstractionType abstraction)
	{
		InstanceOfTheBallType instance = abstraction.InstanceOfTheBall;
		CurrInstance = instance;
		GenerateInstance(instance);
	}	

	InformationObjectType GetInformationObjectByName(string informationObjectName)
    {
		var result = CurrInstance.InformationModel.FirstOrDefault(candidate => candidate.name == informationObjectName);
		if(result == null)
			throw new ArgumentException("Information object not found with name: " + informationObjectName);
		return result;
    }


	enum ObjectType {
		Items,
		Collection,
		MediaContent
    }

	ObjectType GetInformationObjectType(string informationObjectName) 
	{
		var iObj = CurrInstance.InformationModel.Single(item => item.name == informationObjectName);
		Type objType = iObj.Item.GetType();
		if(objType == typeof(InformationItemsType))
			return ObjectType.Items;
		if(objType == typeof(CollectionForType))
			return ObjectType.Collection;
		if(objType == typeof(InformationObjectContentType))
			return ObjectType.MediaContent;
		throw new NotSupportedException("Not supported object type: " + objType.Name);
    }



	void GenerateInstance(InstanceOfTheBallType instance)
	{
		string domainName = instance.semanticDomainName;
		string domainNameMethodPart = domainName.Replace(".", "_");
#>

using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.Common;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Newtonsoft.Json;
using SQLiteSupport;
using System.ComponentModel.DataAnnotations.Schema;
using Key=System.ComponentModel.DataAnnotations.KeyAttribute;
//using ScaffoldColumn=System.ComponentModel.DataAnnotations.ScaffoldColumnAttribute;
//using Editable=System.ComponentModel.DataAnnotations.EditableAttribute;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;


<#+
		BeginNamespace("SQLite." + instance.semanticDomainName);
		GenerateRequiredInterfaceDefinitions(instance);
		GenerateDataContext(instance);
		GenerateDataClasses(instance);
		GenerateM2MRelationClasses(instance);
		EndBlock();
#>


<#+
	}

	string GetTypeFromInterfaceType(InterfaceItemTypeLogicalDataType logicalInterfaceDataType)
    {
		//InterfaceItemTypeLogicalDataType dataType = (InterfaceItemTypeLogicalDataType) System.Enum.Parse(typeof(InterfaceItemTypeLogicalDataType), logicalInterfaceDataType);
		switch(logicalInterfaceDataType)
        {
			case InterfaceItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InterfaceItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InterfaceItemTypeLogicalDataType.Number:
				return "double";
			case InterfaceItemTypeLogicalDataType.Text_Long:
			case InterfaceItemTypeLogicalDataType.Text_Short:
				return "string";
			case InterfaceItemTypeLogicalDataType.Time_Date:
			case InterfaceItemTypeLogicalDataType.Time_DateTime:
			case InterfaceItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			default:
				throw new NotSupportedException("Logical interface data type not supported: " + logicalInterfaceDataType);
        }
    }

	void GenerateRequiredInterfaceDefinitions(InstanceOfTheBallType instance) 
	{
#>

	internal interface ITheBallDataContextStorable
	{
		void PrepareForStoring(bool isInitialInsert);
	}

<#+
    }

	void GenerateDataContext(InstanceOfTheBallType instance)
    {
		var informationObjects = instance.InformationModel;
		string instanceName = instance.semanticDomainName;
		var tableObjects = GetTableObjects(instance.InformationModel);
#>
		public class TheBallDataContext : DbContext, IStorageSyncableDataContext
		{
		    protected override void OnModelCreating(ModelBuilder modelBuilder)
		    {
<#+
		foreach(var iObj in tableObjects)
        {
			string iObjName = iObj.name;
#>
				<#= iObjName #>.EntityConfig(modelBuilder);
<#+
			InformationItemType[] relationProperties = GetRelationProperties(iObj);
			foreach(var relProp in relationProperties)
            {
				var targetObj = GetInformationObjectByName(relProp.objectLinkTargetType);
				var m2mClassName = iObjName + relProp.name;
#>
				<#= m2mClassName #>.EntityConfig(modelBuilder);
<#+
            }
		}
#>

		    }

            // Track whether Dispose has been called. 
            private bool disposed = false;
		    void IDisposable.Dispose()
		    {
		        if (disposed)
		            return;
                GC.Collect();
                GC.WaitForPendingFinalizers();
		        disposed = true;
		    }

            public static Func<DbConnection> GetCurrentConnectionFunc { get; set; }

		    public TheBallDataContext() : base(new DbContextOptions<TheBallDataContext>())
		    {
		        
		    }

		    public readonly string SQLiteDBPath;
		    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
		    {
		        optionsBuilder.UseSqlite($"Filename={SQLiteDBPath}");
		    }

		    public static TheBallDataContext CreateOrAttachToExistingDB(string pathToDBFile)
		    {
		        var sqliteConnectionString = $"{pathToDBFile}";
                var dataContext = new TheBallDataContext(sqliteConnectionString);
		        var db = dataContext.Database;
                db.OpenConnection();
		        using (var transaction = db.BeginTransaction())
		        {
                    dataContext.CreateDomainDatabaseTablesIfNotExists();
                    transaction.Commit();
		        }
                return dataContext;
		    }

            public TheBallDataContext(string sqLiteDBPath) : base()
            {
                SQLiteDBPath = sqLiteDBPath;
            }

		    public override int SaveChanges(bool acceptAllChangesOnSuccess)
		    {
                //if(connection.State != ConnectionState.Open)
                //    connection.Open();
		        return base.SaveChanges(acceptAllChangesOnSuccess);
		    }

			/*
            public override void SubmitChanges(ConflictMode failureMode)
            {
                var changeSet = GetChangeSet();
                var insertsToProcess = changeSet.Inserts.Where(insert => insert is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in insertsToProcess)
                    itemToProcess.PrepareForStoring(true);
                var updatesToProcess = changeSet.Updates.Where(update => update is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in updatesToProcess)
                    itemToProcess.PrepareForStoring(false);
                base.SubmitChanges(failureMode);
            }

		    public async Task SubmitChangesAsync()
		    {
		        await Task.Run(() => SubmitChanges());
		    }
			*/

			public void CreateDomainDatabaseTablesIfNotExists()
			{
				List<string> tableCreationCommands = new List<string>();
                tableCreationCommands.AddRange(InformationObjectMetaData.GetMetaDataTableCreateSQLs());
<#+
		foreach(var iObj in tableObjects)
        {
			string iObjName = iObj.name;
#>
				tableCreationCommands.Add(<#= iObjName #>.GetCreateTableSQL());
<#+
			InformationItemType[] relationProperties = GetRelationProperties(iObj);
			foreach(var relProp in relationProperties)
            {
				string m2mTableClassName = iObj.name + relProp.name;
#>
				tableCreationCommands.Add(<#= m2mTableClassName #>.GetCreateTableSQL());
<#+

            }

        }
#>
			    //var connection = this.Connection;
			    var db = this.Database;
			    var connection = db.GetDbConnection();
				foreach (string commandText in tableCreationCommands)
			    {
			        var command = connection.CreateCommand();
			        command.CommandText = commandText;
                    command.CommandType = CommandType.Text;
			        command.ExecuteNonQuery();
			    }
			}

			public DbSet<InformationObjectMetaData> InformationObjectMetaDataTable {
				get {
					return this.Set<InformationObjectMetaData>();
				}
			}

<#+
		GeneratePerformUpdate(CurrInstance.semanticDomainName, tableObjects, false);			
		GeneratePerformUpdate(CurrInstance.semanticDomainName, tableObjects, true);			
		GeneratePerformInsert(CurrInstance.semanticDomainName, tableObjects, false);			
		GeneratePerformInsert(CurrInstance.semanticDomainName, tableObjects, true);			
		GeneratePerformDelete(CurrInstance.semanticDomainName, tableObjects, false);			
		GeneratePerformDelete(CurrInstance.semanticDomainName, tableObjects, true);			

		foreach(var informationObject in GetTableObjects(informationObjects))
        {
			string iObjName = informationObject.name;
#>
			public DbSet<<#= iObjName #>> <#= iObjName #>Table { get; set; }
<#+
			InformationItemType[] relationProperties = GetRelationProperties(informationObject);
			foreach(InformationItemType relProp in relationProperties)
            {
				string tableClassName = informationObject.name + relProp.name;
#>
			public DbSet<<#= tableClassName #>> <#= tableClassName #>Table { get; set; }
<#+
            }
        }
#>
        }

<#+

    }

	void GeneratePerformUpdate(string semanticDomainName, InformationObjectType[] tableObjects, bool generateAsAsync)
    {
		string asyncStr = generateAsAsync ? "Async" : "";
		string awaitStr = generateAsAsync ? "await" : "";
		string asyncAndReturnValue = generateAsAsync ? "async Task" : "void";
#>

			public <#= asyncAndReturnValue #> PerformUpdate<#= asyncStr #>(string storageRootPath, InformationObjectMetaData updateData)
		    {
                if(updateData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");

				switch(updateData.ObjectType)
				{
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
			InformationItemsType itemsType = informationObject.Item as InformationItemsType;
			if(itemsType != null) {
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
#>
		        case "<#= informationObject.name #>":
		        {
		            string currentFullStoragePath = Path.Combine(storageRootPath, updateData.CurrentStoragePath);
		            var serializedObject = 
		                global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
		                    <#= awaitStr #> ContentStorage.GetContentAsString<#= asyncStr #>(currentFullStoragePath));
		            var existingObject = <#= informationObject.name #>Table.Single(item => item.ID == updateData.ObjectID);
					existingObject.ETag = updateData.ETag;
<#+
				foreach(var informationItem in currentSupportedItems) 
				{
					bool isImplicitCollection = informationItem.isCollection;
					bool isObjectItem = informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
					string objectName = informationItem.informationObjectName;
					bool isObjectCollection = isObjectItem && GetInformationObjectType(informationItem.informationObjectName) == ObjectType.Collection;
					string sourcePropertyName = informationItem.name;
					string targetPropertyName = informationItem.name;
					bool isCollection = informationItem.isCollection;
					bool isObjectLink = informationItem.logicalDataType == InformationItemTypeLogicalDataType.ObjectLink;

					if(isObjectLink) {
						string linkClassName = informationObject.name + informationItem.name;
						string sourceIDName = informationObject.name + "ID";
						string targetIDName = informationItem.objectLinkTargetType + "ID";
						string propertyName = informationItem.name;
#>
                    if (serializedObject.<#= sourcePropertyName #> != null)
                    {
<#+
						if(isCollection) {
#>
						existingObject.<#= propertyName #>.Clear();
                        serializedObject.<#= sourcePropertyName #>.ForEach(
                            item =>
                            {
                                var relationObject = new <#= linkClassName #>
                                {
                                    <#= sourceIDName #> = existingObject.ID,
                                    <#= targetIDName #> = item
                                };
                                <#= linkClassName #>Table.Add(relationObject);
                                existingObject.<#= propertyName #>.Add(relationObject);

                            });
<#+
                        } else {
#>
                            var relationObject = new <#= linkClassName #>
                            {
                                <#= sourceIDName #> = existingObject.ID,
                                <#= targetIDName #> = serializedObject.<#= sourcePropertyName #>
                            };
                            <#= linkClassName #>Table.Add(relationObject);
							existingObject.<#= propertyName #> = relationObject;
<#+ 
                        }
#>
                    }

<#+
                    } else if(isObjectItem && !isImplicitCollection) {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						existingObject.<#= targetPropertyName #>ID = serializedObject.<#= sourcePropertyName #>.ID;
					else
						existingObject.<#= targetPropertyName #>ID = null;
<#+
					} else if(!isImplicitCollection) {
#>
		            existingObject.<#= targetPropertyName #> = serializedObject.<#= sourcePropertyName #>;
<#+
					} else {
#>
                    existingObject.<#= targetPropertyName #>.Clear();
					if(serializedObject.<#= sourcePropertyName #> != null)
	                    serializedObject.<#= sourcePropertyName #>.ForEach(item => existingObject.<#= targetPropertyName #>.Add(item));
					
<#+
					}
                }
			#>
		            break;
		        } 
<#+
            }
        }
#>
				}
		    }

<#+
    }

	void GeneratePerformInsert(string semanticDomainName, InformationObjectType[] tableObjects, bool generateAsAsync)
    {
		string asyncStr = generateAsAsync ? "Async" : "";
		string awaitStr = generateAsAsync ? "await" : "";
		string asyncAndReturnValue = generateAsAsync ? "async Task" : "void";
#>
		    public <#= asyncAndReturnValue #> PerformInsert<#= asyncStr #>(string storageRootPath, InformationObjectMetaData insertData)
		    {
                if (insertData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
                InformationObjectMetaDataTable.Add(insertData);

				switch(insertData.ObjectType)
				{
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
			InformationItemsType itemsType = informationObject.Item as InformationItemsType;
			if(itemsType != null) {
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
#>
                case "<#= informationObject.name #>":
                {
                    string currentFullStoragePath = Path.Combine(storageRootPath, insertData.CurrentStoragePath);
                    var serializedObject =
                        global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
                            <#= awaitStr #> ContentStorage.GetContentAsString<#= asyncStr #>(currentFullStoragePath));
                    var objectToAdd = new <#= informationObject.name #> {ID = insertData.ObjectID, ETag = insertData.ETag};
<#+
				foreach(var informationItem in currentSupportedItems) 
				{
					bool isImplicitCollection = informationItem.isCollection;
					bool isObjectItem = informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
					bool isObjectCollection = isObjectItem && GetInformationObjectType(informationItem.informationObjectName) == ObjectType.Collection;
					bool isObjectLink = informationItem.logicalDataType == InformationItemTypeLogicalDataType.ObjectLink;
					bool isCollection = informationItem.isCollection;
					string objectName = informationItem.informationObjectName;

					string sourcePropertyName = informationItem.name;
					string targetPropertyName = informationItem.name;

					if(isObjectLink) {
						string linkClassName = informationObject.name + informationItem.name;
						string sourceIDName = informationObject.name + "ID";
						string targetIDName = informationItem.objectLinkTargetType + "ID";
						string propertyName = informationItem.name;
#>
                    if (serializedObject.<#= sourcePropertyName #> != null)
                    {
<#+
						if(isCollection) {
#>
                        serializedObject.<#= sourcePropertyName #>.ForEach(
                            item =>
                            {
                                var relationObject = new <#= linkClassName #>
                                {
                                    <#= sourceIDName #> = objectToAdd.ID,
                                    <#= targetIDName #> = item
                                };
                                <#= linkClassName #>Table.Add(relationObject);
                                objectToAdd.<#= propertyName #>.Add(relationObject);

                            });
<#+
                        } else {
#>
                            var relationObject = new <#= linkClassName #>
                            {
                                <#= sourceIDName #> = objectToAdd.ID,
                                <#= targetIDName #> = serializedObject.<#= sourcePropertyName #>
                            };
                            <#= linkClassName #>Table.Add(relationObject);
                            objectToAdd.<#= propertyName #> = relationObject;
<#+ 
                        }
#>
                    }

<#+
                    } else if(isObjectItem && !isImplicitCollection) {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						objectToAdd.<#= targetPropertyName #>ID = serializedObject.<#= sourcePropertyName #>.ID;
					else
						objectToAdd.<#= targetPropertyName #>ID = null;
<#+
	                } else if(!isImplicitCollection) {
#>
		            objectToAdd.<#= targetPropertyName #> = serializedObject.<#= sourcePropertyName #>;
<#+
		            } else {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						serializedObject.<#= sourcePropertyName #>.ForEach(item => objectToAdd.<#= targetPropertyName #>.Add(item));
<#+
			        }
                }
			 #>
					<#= informationObject.name #>Table.Add(objectToAdd);
                    break;
                }
<#+			}
        }
 #>
				}
            }


<#+
    }

	void GeneratePerformDelete(string semanticDomainName, InformationObjectType[] tableObjects, bool generateAsAsync)
    {
		string asyncStr = generateAsAsync ? "Async" : "";
		string awaitStr = generateAsAsync ? "await" : "";
		string asyncAndReturnValue = generateAsAsync ? "async Task" : "void";
#>
		    public <#= asyncAndReturnValue #> PerformDelete<#= asyncStr #>(string storageRootPath, InformationObjectMetaData deleteData)
		    {
                if (deleteData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
				InformationObjectMetaDataTable.Remove(deleteData);

				switch(deleteData.ObjectType)
				{
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;

#>
					case "<#= informationObject.name #>":
					{
						//var objectToDelete = new <#= informationObject.name #> {ID = deleteData.ObjectID};
						//<#= informationObject.name #>Table.Attach(objectToDelete);
						var objectToDelete = <#= informationObject.name #>Table.SingleOrDefault(item => item.ID == deleteData.ObjectID);
						if(objectToDelete != null)
							<#= informationObject.name #>Table.Remove(objectToDelete);
						break;
					}
<#+		} #>
				}
			}



<#+
    }

	InformationObjectType[] GetTableObjects(InformationObjectType[] informationObjects) 
	{
		var informationItemObjects = informationObjects.Where(iObj => iObj.Item is InformationItemsType)
			.Where(iObj => GetSupportedInformationItems(((InformationItemsType) iObj.Item).InformationItem).Length > 0).ToArray();
		var collectionObjects = informationObjects.Where(iObj => GetInformationObjectType(iObj.name) == ObjectType.Collection);
		return informationItemObjects.Concat(collectionObjects).ToArray();
    }

	InformationItemType[] GetRelationProperties(InformationObjectType iObj)
    {
		InformationItemsType informationItems = iObj.Item as InformationItemsType;
		if(informationItems == null)
			return new InformationItemType[0];
		return informationItems.InformationItem.Where(item => item.logicalDataType == InformationItemTypeLogicalDataType.ObjectLink).ToArray();
    }

	void GenerateDataClasses(InstanceOfTheBallType instance) 
	{
		foreach(var iObj in GetTableObjects(instance.InformationModel)) 
		{
			GenerateDataClass(iObj);
        }
    }

	void GenerateM2MRelationClasses(InstanceOfTheBallType instance)
    {
		foreach(var iObj in GetTableObjects(instance.InformationModel))
        {
			InformationItemType[] relationProperties = GetRelationProperties(iObj);
			foreach(var relProp in relationProperties)
            {
				var targetObj = GetInformationObjectByName(relProp.objectLinkTargetType);
				GenerateM2MRelationClass(iObj, targetObj, relProp.name, relProp.isCollection);
            }
        }
    }

	InformationItemType[] GetSupportedInformationItems(InformationItemType[] sourceItems) 
	{
		//var currentSupportedItems = sourceItems.Where(item => string.IsNullOrEmpty(item.informationObjectName)).ToArray();
		var currentSupportedItems = sourceItems.Where(item => item.name != "ParentCategoryID").ToArray();
		return currentSupportedItems;
    }

	void GenerateM2MRelationClass(InformationObjectType sourceObject, InformationObjectType targetObject, string sourcePropertyName, bool isCollection)
    {
		string sourceClassName = sourceObject.name;
		string targetClassName = targetObject.name;
		//string tableName = sourceClassName + sourcePropertyName + "LNK";
		string className = sourceClassName + sourcePropertyName;
		string sourceIDName = sourceClassName + "ID";
		string targetIDName = targetClassName + "ID";
#>
    [Table("<#= className #>")]
	//[ScaffoldTable(true)]
	[DebuggerDisplay("<#= className #>: {<#= sourceIDName #>} - {<#= targetIDName #>}")]
	public class <#= className #> // : ITheBallDataContextStorable
	{
        public static string GetCreateTableSQL()
        {
            return
                @"
CREATE TABLE IF NOT EXISTS [<#= className #>](
[<#= sourceIDName #>] TEXT NOT NULL, 
[<#= targetIDName #>] TEXT NOT NULL,
PRIMARY KEY (<#= sourceIDName #>, <#= targetIDName #>)
)";
        }

		public static void EntityConfig(ModelBuilder modelBuilder) {
		    modelBuilder.Entity<<#= className #>>()
		        .HasKey(c => new { c.<#= sourceIDName #>, c.<#= targetIDName #>});
			
		}


        //[Column(IsPrimaryKey = true, CanBeNull = false)]
        public string <#= sourceIDName #> { get; set; }
        //[Column(IsPrimaryKey = true, CanBeNull = false)]
        public string <#= targetIDName #> { get; set; }


        //private EntityRef<<#= sourceClassName #>> _<#= sourceClassName #> = new EntityRef<<#= sourceClassName #>>();
        //[Association(DeleteOnNull = true, IsForeignKey = true, ThisKey = "<#= sourceIDName #>", OtherKey = "ID", 
		//	Storage = "_<#= sourceClassName #>", IsUnique = <#= (!isCollection).ToString().ToLower() #>)]
        public <#= sourceClassName #> <#= sourceClassName #> { get; set; }

        //private EntityRef<<#= targetClassName #>> _<#= targetClassName #> = new EntityRef<<#= targetClassName #>>();
        //[Association(DeleteOnNull = true, IsForeignKey = true, ThisKey = "<#= targetIDName #>", OtherKey = "ID", 
		//	Storage = "_<#= targetClassName #>")]
		public <#= targetClassName #> <#= targetClassName #> { get; set; }

    }

<#+
    }

	void GenerateDataClass(InformationObjectType informationObject)
	{
		string semanticDomainName = CurrInstance.semanticDomainName;
		string objectName = informationObject.name;
		string informationObjectName = informationObject.name;
		CollectionForType collType = informationObject.Item as CollectionForType;
		bool isCollection = collType != null;

		//bool containsCollection = itemsType != null && itemsType.InformationItem.Any(item => item.isCollection);

		bool provideDefaultCreate = informationObject.provideCreateMethod;
		bool isIndependentMaster = informationObject.isIndependentMaster;

#>
    [Table("<#= objectName #>")]
	//[ScaffoldTable(true)]
	[DebuggerDisplay("<#= objectName #>: {ID}")]
	public class <#= objectName #> : ITheBallDataContextStorable
	{
		public static void EntityConfig(ModelBuilder modelBuilder) {
		}

		//[Column(IsPrimaryKey = true)]
        //[ScaffoldColumn(true)]
		[Key]
        //[Editable(false)]
		public string ID { get; set; }

		//[Column]
        //[ScaffoldColumn(true)]
        //[Editable(false)]
		public string ETag { get; set; }


		public <#= objectName #>() 
		{
			ID = Guid.NewGuid().ToString();
			ETag = String.Empty;
		}

<#+
		InformationItemsType itemsType = informationObject.Item as InformationItemsType;
		CollectionForType collectionType = informationObject.Item as CollectionForType;
		if(itemsType != null) {
			var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
			GenerateSQLiteCreationFunction(objectName, currentSupportedItems);
			GenerateInformationItems(informationObject, currentSupportedItems);
			GenerateInterfaceImplementation(currentSupportedItems);
        } else if(collectionType != null) {
			GenerateSQLiteCreationFunction(objectName, collectionType);
			GenerateInterfaceImplementation(collectionType);
#>
		//[Column(IsPrimaryKey = true)]
        //[ScaffoldColumn(true)]
        //[Editable(false)]
		public string CollectionItemID { get; set; }
<#+
        }
#>
	}
<#+
    }

	void GenerateInterfaceImplementation(CollectionForType collection) 
	{
#>
        public void PrepareForStoring(bool isInitialInsert)
        {
		}
<#+
    }

	void GenerateInterfaceImplementation(InformationItemType[] informationItems) 
	{
		var currentSupportedItems = GetSupportedInformationItems(informationItems);
		var customsStorableObjects = currentSupportedItems.Where(iItem => iItem.isCollection && iItem.logicalDataType != InformationItemTypeLogicalDataType.ObjectLink).ToArray();
		var stringItems = currentSupportedItems.Where(iItem => iItem.isCollection == false && String.IsNullOrEmpty(iItem.objectLinkTargetType) && GetPlatformDataTypeFromLogical(iItem.logicalDataType, iItem.informationObjectName) == "string").ToArray();

#>
        public void PrepareForStoring(bool isInitialInsert)
        {
		
<#+
		foreach(var stringItem in stringItems) 
		{
#>
			if(<#= stringItem.name #> == null)
				<#= stringItem.name #> = string.Empty;
<#+			
        }
		foreach(var item in customsStorableObjects) 
		{

#>
            if (_Is<#= item.name #>Changed || isInitialInsert)
            {
                var dataToStore = <#= item.name #>.ToArray();
                <#= item.name #>Data = JsonConvert.SerializeObject(dataToStore);
            }

<#+
        }

#>
		}
<#+
    }

	void GenerateSQLiteCreationFunction(string informationObjectName, CollectionForType collectionType)
    { 
#>
        public static string GetCreateTableSQL()
        {
            return
                @"
CREATE TABLE IF NOT EXISTS [<#= informationObjectName #>](
[ID] TEXT NOT NULL, 
[CollectionItemID] TEXT NOT NULL, 
[ETag] TEXT NOT NULL,
	PRIMARY KEY (ID) )";
        }

<#+
	}

	void GenerateSQLiteCreationFunction(string informationObjectName, InformationItemType[] informationItems) 
    {
#>
        public static string GetCreateTableSQL()
        {
            return
                @"
CREATE TABLE IF NOT EXISTS [<#= informationObjectName #>](
[ID] TEXT NOT NULL PRIMARY KEY, 
[ETag] TEXT NOT NULL
<#+
			var itemArray = informationItems.Select(item => {
				Tuple<string, string, string> fieldData = GetSQLFieldNameDataTypeNullDeclaration(item);
				if(fieldData == null)
					return null;
				var fieldName = fieldData.Item1;
				var dataType = fieldData.Item2;
				var defaultClause = dataType == "TEXT" ? "DEFAULT ''" : null;
				var notNullClause = defaultClause ?? fieldData.Item3;
				return string.Format("[{0}] {1} {2}", fieldName, dataType, notNullClause);
            }).Where(clause => clause != null).ToArray();
			string wholePart = string.Join(", " + Environment.NewLine, itemArray);
			if(wholePart != string.Empty)
				wholePart = ", " + Environment.NewLine + wholePart;
#><#= wholePart #>
)";
        }

<#+
    }

	Tuple<string, string, string> GetSQLFieldNameDataTypeNullDeclaration(InformationItemType item) {
		bool isObjectType = item.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
		bool isObjectLinkType = item.logicalDataType == InformationItemTypeLogicalDataType.ObjectLink;
		string fieldName;
		string dataType;
		string notNullClause;
		if(isObjectLinkType) // no SQL at all for link types; handled with ID references and additional classes
			return null;

		if(!isObjectType) 
		{
			fieldName = item.name;
			dataType = GetSQLiteTypeFromLogicalType(item.logicalDataType);
			if(item.isCollection || isObjectType)
				dataType = "TEXT";
			notNullClause = "NOT NULL";
			return new Tuple<string, string, string>(fieldName, dataType, notNullClause);
        } else {
			//ObjectType objType = GetInformationObjectType(item.informationObjectName);
			dataType = "TEXT";
			//if(objType == ObjectType.Items || objType == ObjectType.MediaContent)
			fieldName = item.name + "ID";
			//else 
			//	return null;
			notNullClause = "NULL";
        }
		return new Tuple<string, string, string>(fieldName, dataType, notNullClause);
    }

	void GenerateInformationItemsMethods(string informationObjectName, InformationItemType[] informationItems)
	{
		InformationItemType[] informationObjects = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName) == false).ToArray();
		//InformationItemType[] nonMasterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == false).ToArray();
		//InformationItemType[] masterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == true).ToArray();
		InformationItemType[] primitiveItems = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName)).ToArray();
		bool containsCollection = informationItems.Any(item => item.isCollection);
		string domainName = CurrentAbstraction.InstanceOfTheBall.semanticDomainName;
		if(containsCollection == false) {
        }
    }
	
	void GenerateInformationItems(InformationObjectType iObj, InformationItemType[] informationItems)
	{
		foreach(var item in informationItems)
		{
			if(item.logicalDataType == InformationItemTypeLogicalDataType.ObjectLink) {
				GenerateObjectLinkEntityItem(iObj, item);
            } else {
				if(item.logicalDataType != InformationItemTypeLogicalDataType.InformationObject || item.isCollection) 
					GenerateDataItem(iObj, item);
				else
					GenerateEntityItem(iObj, item);
            }
        }
    }

	void GenerateObjectLinkEntityItem(InformationObjectType iObj, InformationItemType item)
    {
		bool isCollection = item.isCollection;
		Func<string, string> collectionRef = str => $"List<{str}>";
		Func<string, string> singleRef = str => str;
		var entityRefFunc = isCollection ?  collectionRef : singleRef;
		string entityRefType = "obsoleted";
		string sourceName = iObj.name;
		string sourceIDName = sourceName + "ID";
		string propertyName = item.name;
		string fieldName = "_" + propertyName;
		string targetClassName = sourceName + propertyName;
		if(isCollection) {
#>
		//private <#= entityRefType #><<#= targetClassName #>> <#= fieldName #> = new <#= entityRefType #><<#= targetClassName #>>();
        //[Association(ThisKey = "ID", OtherKey = "<#= sourceIDName #>", Storage="<#= fieldName #>")]
        public <#= entityRefFunc(targetClassName) #> <#= propertyName #> { 
			get; 
			set;
			//get { return <#= fieldName #>; }
			//set { <#= fieldName #>.Assign(value); }
		}

<#+
        } else {

#>
		//private <#= entityRefType #><<#= targetClassName #>> <#= fieldName #> = new <#= entityRefType #><<#= targetClassName #>>();
        //[Association(ThisKey = "ID", OtherKey = "<#= sourceIDName #>", Storage="<#= fieldName #>")]
        public <#= targetClassName #> <#= propertyName #> 
		{ 
			get;
			set;
			//get { return <#= fieldName #>.Entity; }
			//set { <#= fieldName #>.Entity = value; }
		}

<#+
        }
    }

	void GenerateEntityItem(InformationObjectType iObj, InformationItemType item)
    {
		string objectName = item.informationObjectName;
		//if(ItemTypesToIgnore.Contains(objectName))
		//	return;
		if(item.isCollection)  // Generated as data item with serializable type
			return;
		ObjectType objectType = GetInformationObjectType(objectName);
		if(objectType == ObjectType.Collection) {
			var collectionObject = GetInformationObjectByName(objectName);
			string objectPropName = item.name;
			string idPropName = objectPropName + "ID";
			var collectionFor = (CollectionForType) collectionObject.Item;
			var linkedObjectName = collectionFor.contentInformationObjectName;
#>
			//[Column]
			public string <#= idPropName #> { get; set; }
			private EntityRef< <#= objectName #> > _<#= objectPropName #>;
			[Association(Storage = "_<#= objectPropName  #>", ThisKey = "<#= idPropName #>")]
			public <#= objectName #> <#= objectPropName #>
			{
				get { return this._<#= objectPropName #>.Entity; }
				set { this._<#= objectPropName #>.Entity = value; }
			}
<#+

        } else if(objectType == ObjectType.MediaContent) {
			string objectPropName = item.name;
			string idPropName = objectPropName + "ID";
#>
			//[Column]
			public string <#= idPropName #> { get; set; }
<#+
        } else { // items
			string objectPropName = item.name;
			string idPropName = objectPropName + "ID";
#>
			//[Column]
			public string <#= idPropName #> { get; set; }
			private EntityRef< <#= objectName #> > _<#= objectPropName #>;
			[Association(Storage = "_<#= objectPropName  #>", ThisKey = "<#= idPropName #>")]
			public <#= objectName #> <#= objectPropName #>
			{
				get { return this._<#= objectPropName #>.Entity; }
				set { this._<#= objectPropName #>.Entity = value; }
			}

<#+
        }
    }

	void GenerateDataItem(InformationObjectType iObj, InformationItemType item) 
	{
		if(iObj.name == "Category" && item.name == "ParentCategoryID")
			return;
		string dataType = GetPlatformDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
		bool isObjectItem = item.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
		bool isCollection = item.isCollection;
		if(isCollection)
        {
			string dataTypePrefix = isObjectItem ? "SER." + CurrentAbstraction.InstanceOfTheBall.semanticDomainName + "." : "";
			dataType = dataTypePrefix + dataType;
#>
        //[Column(Name = "<#= item.name #>")] 
        //[ScaffoldColumn(true)]
		public string <#= item.name #>Data { get; set; }

        private bool _Is<#= item.name #>Retrieved = false;
        private bool _Is<#= item.name #>Changed = false;
        private ObservableCollection<<#= dataType #>> _<#= item.name #> = null;
        [NotMapped]
		public ObservableCollection<<#= dataType #>> <#= item.name #>
        {
            get
            {
                if (!_Is<#= item.name #>Retrieved)
                {
                    if (<#= item.name #>Data != null)
                    {
                        var arrayData = JsonConvert.DeserializeObject<<#= dataType #>[]>(<#= item.name #>Data);
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>(arrayData);
                    }
                    else
                    {
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>();
						<#= item.name #>Data = Guid.NewGuid().ToString();
						_Is<#= item.name #>Changed = true;
                    }
                    _Is<#= item.name #>Retrieved = true;
                    _<#= item.name #>.CollectionChanged += (sender, args) =>
						{
							<#= item.name #>Data = Guid.NewGuid().ToString();
							_Is<#= item.name #>Changed = true;
						};
                }
                return _<#= item.name #>;
            }
            set 
			{ 
				_<#= item.name #> = value; 
                // Reset the data field to unique value
                // to trigger change on object, just in case nothing else changed
                _Is<#= item.name #>Retrieved = true;
                <#= item.name #>Data = Guid.NewGuid().ToString();
                _Is<#= item.name #>Changed = true;

			}
        }

<#+
        } else {
#>

		//[Column]
        //[ScaffoldColumn(true)]
		public <#= dataType #> <#= item.name #> { get; set; }
		// private <#= dataType #> _unmodified_<#= item.name #>;
<#+
        }
	}

	string GetPlatformDataTypeFromLogical(InformationItemTypeLogicalDataType logicalDataType, string informationObjectName)
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
				return "double";
			//case InformationItemTypeLogicalDataType.Number_CustomFormat:
			//	return "string";
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "double";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "long";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
			case InformationItemTypeLogicalDataType.ObjectLink:
				return "string";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InformationItemTypeLogicalDataType.InformationObject:
				return informationObjectName;
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
	}

	string GetSQLiteTypeFromLogicalType(InformationItemTypeLogicalDataType logicalDataType) 
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "BLOB";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "REAL";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
			case InformationItemTypeLogicalDataType.ObjectLink:
				return "TEXT";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "TEXT";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.InformationObject:
				return "TEXT";
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
    }



#>