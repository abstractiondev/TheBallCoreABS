<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>

<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			InstanceRelationsTableList.Clear();
			this.GenerationEnvironment.Clear();
			ItemTypesToIgnore.Clear();
			ItemTypesToIgnore.Add("MediaContent");
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + "_SQLite.designer.cs";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InstanceOfTheBallType CurrInstance;

	List<string> ItemTypesToIgnore = new List<string>();
	List< Tuple<string, string, string> > InstanceRelationsTableList = new List< Tuple<string, string, string> >();
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}

	void GenerateAbstraction(TheBallCoreAbstractionType abstraction)
	{
		InstanceOfTheBallType instance = abstraction.InstanceOfTheBall;
		CurrInstance = instance;
		GenerateInstance(instance);
	}	

	InformationObjectType GetInformationObjectByName(string informationObjectName)
    {
		var result = CurrInstance.InformationModel.FirstOrDefault(candidate => candidate.name == informationObjectName);
		if(result == null)
			throw new ArgumentException("Information object not found with name: " + informationObjectName);
		return result;
    }


	enum ObjectType {
		Items,
		Collection,
		MediaContent
    }

	ObjectType GetInformationObjectType(string informationObjectName) 
	{
		var iObj = CurrInstance.InformationModel.Single(item => item.name == informationObjectName);
		Type objType = iObj.Item.GetType();
		if(objType == typeof(InformationItemsType))
			return ObjectType.Items;
		if(objType == typeof(CollectionForType))
			return ObjectType.Collection;
		if(objType == typeof(InformationObjectContentType))
			return ObjectType.MediaContent;
		throw new NotSupportedException("Not supported object type: " + objType.Name);
    }



	void GenerateInstance(InstanceOfTheBallType instance)
	{
		string domainName = instance.semanticDomainName;
		string domainNameMethodPart = domainName.Replace(".", "_");
#>

using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.Common;
using System.Data.SQLite;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Newtonsoft.Json;
using SQLiteSupport;
using ScaffoldColumn=System.ComponentModel.DataAnnotations.ScaffoldColumnAttribute;
using ScaffoldTable=System.ComponentModel.DataAnnotations.ScaffoldTableAttribute;
using Editable=System.ComponentModel.DataAnnotations.EditableAttribute;


<#+
		BeginNamespace("SQLite." + instance.semanticDomainName);
		GenerateRequiredInterfaceDefinitions(instance);
		GenerateDataContext(instance);
		GenerateDataClasses(instance);
		EndBlock();
#>


<#+
	}

	string GetTypeFromInterfaceType(InterfaceItemTypeLogicalDataType logicalInterfaceDataType)
    {
		//InterfaceItemTypeLogicalDataType dataType = (InterfaceItemTypeLogicalDataType) System.Enum.Parse(typeof(InterfaceItemTypeLogicalDataType), logicalInterfaceDataType);
		switch(logicalInterfaceDataType)
        {
			case InterfaceItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InterfaceItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InterfaceItemTypeLogicalDataType.Number:
				return "double";
			case InterfaceItemTypeLogicalDataType.Text_Long:
			case InterfaceItemTypeLogicalDataType.Text_Short:
				return "string";
			case InterfaceItemTypeLogicalDataType.Time_Date:
			case InterfaceItemTypeLogicalDataType.Time_DateTime:
			case InterfaceItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			default:
				throw new NotSupportedException("Logical interface data type not supported: " + logicalInterfaceDataType);
        }
    }

	void GenerateRequiredInterfaceDefinitions(InstanceOfTheBallType instance) 
	{
#>

	internal interface ITheBallDataContextStorable
	{
		void PrepareForStoring(bool isInitialInsert);
	}

<#+
    }

	void GenerateDataContext(InstanceOfTheBallType instance)
    {
		var informationObjects = instance.InformationModel;
		string instanceName = instance.semanticDomainName;
		var tableObjects = GetTableObjects(instance.InformationModel);
#>
		public class TheBallDataContext : DataContext, IStorageSyncableDataContext
		{
            // Track whether Dispose has been called. 
            private bool disposed = false;
		    protected override void Dispose(bool disposing)
		    {
		        if (disposed)
		            return;
                base.Dispose(disposing);
                GC.Collect();
                GC.WaitForPendingFinalizers();
		        disposed = true;
		    }

            public static Func<DbConnection> GetCurrentConnectionFunc { get; set; }

		    public TheBallDataContext() : base(GetCurrentConnectionFunc())
		    {
		        
		    }

		    public static TheBallDataContext CreateOrAttachToExistingDB(string pathToDBFile)
		    {
		        SQLiteConnection connection = new SQLiteConnection(String.Format("Data Source={0}", pathToDBFile));
                var dataContext = new TheBallDataContext(connection);
				dataContext.CreateDomainDatabaseTablesIfNotExists();
				return dataContext;
		    }

            public TheBallDataContext(SQLiteConnection connection) : base(connection)
		    {
                if(connection.State != ConnectionState.Open)
                    connection.Open();
		    }

            public override void SubmitChanges(ConflictMode failureMode)
            {
                var changeSet = GetChangeSet();
                var insertsToProcess = changeSet.Inserts.Where(insert => insert is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in insertsToProcess)
                    itemToProcess.PrepareForStoring(true);
                var updatesToProcess = changeSet.Updates.Where(update => update is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in updatesToProcess)
                    itemToProcess.PrepareForStoring(false);
                base.SubmitChanges(failureMode);
            }

			public void CreateDomainDatabaseTablesIfNotExists()
			{
				List<string> tableCreationCommands = new List<string>();
                tableCreationCommands.AddRange(InformationObjectMetaData.GetMetaDataTableCreateSQLs());
<#+
		foreach(var informationObject in tableObjects)
        {
			string iObjName = informationObject.name;
#>
				tableCreationCommands.Add(<#= iObjName #>.GetCreateTableSQL());
<#+
        }
#>
			    var connection = this.Connection;
				foreach (string commandText in tableCreationCommands)
			    {
			        var command = connection.CreateCommand();
			        command.CommandText = commandText;
                    command.CommandType = CommandType.Text;
			        command.ExecuteNonQuery();
			    }
			}

			public Table<InformationObjectMetaData> InformationObjectMetaDataTable {
				get {
					return this.GetTable<InformationObjectMetaData>();
				}
			}

			public void PerformUpdate(string storageRootPath, InformationObjectMetaData updateData)
		    {
                if(updateData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
#>
		        if (updateData.ObjectType == "<#= informationObject.name #>")
		        {
		            string currentFullStoragePath = Path.Combine(storageRootPath, updateData.CurrentStoragePath);
		            var serializedObject =
		                global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
		                    ContentStorage.GetContentAsString(currentFullStoragePath));
		            var existingObject = <#= informationObject.name #>Table.Single(item => item.ID == updateData.ObjectID);
					existingObject.ETag = updateData.ETag;
<#+
			foreach(var informationItem in currentSupportedItems) 
			{
				bool isImplicitCollection = informationItem.isCollection;
				bool isObjectItem = informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
				bool isObjectCollection = isObjectItem && GetInformationObjectType(informationItem.informationObjectName) == ObjectType.Collection;
				string sourcePropertyName = informationItem.name;
				string targetPropertyName = informationItem.name;
				if(isObjectItem) {
					if(isObjectCollection)
						continue;
					//sourcePropertyName = informationItem.name + ".ID";
					//targetPropertyName = informationItem.name + "ID";
                } else {
					//sourcePropertyName = informationItem.name;
					//targetPropertyName = informationItem.name;
                }
				if(isObjectItem && !isImplicitCollection) {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						existingObject.<#= targetPropertyName #>ID = serializedObject.<#= sourcePropertyName #>.ID;
					else
						existingObject.<#= targetPropertyName #>ID = null;
<#+

                } else if(!isImplicitCollection) {
#>
		            existingObject.<#= targetPropertyName #> = serializedObject.<#= sourcePropertyName #>;
<#+
                } else {
#>
                    existingObject.<#= targetPropertyName #>.Clear();
					if(serializedObject.<#= sourcePropertyName #> != null)
	                    serializedObject.<#= sourcePropertyName #>.ForEach(item => existingObject.<#= targetPropertyName #>.Add(item));
					
<#+
                }
			} #>
		            return;
		        } 
<#+
        }
#>
		    }

		    public void PerformInsert(string storageRootPath, InformationObjectMetaData insertData)
		    {
                if (insertData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
                InformationObjectMetaDataTable.InsertOnSubmit(insertData);
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);

#>
                if (insertData.ObjectType == "<#= informationObject.name #>")
                {
                    string currentFullStoragePath = Path.Combine(storageRootPath, insertData.CurrentStoragePath);
                    var serializedObject =
                        global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
                            ContentStorage.GetContentAsString(currentFullStoragePath));
                    var objectToAdd = new <#= informationObject.name #> {ID = insertData.ObjectID, ETag = insertData.ETag};
<#+
			foreach(var informationItem in currentSupportedItems) 
			{
				bool isImplicitCollection = informationItem.isCollection;
				bool isObjectItem = informationItem.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
				bool isObjectCollection = isObjectItem && GetInformationObjectType(informationItem.informationObjectName) == ObjectType.Collection;
				string sourcePropertyName = informationItem.name;
				string targetPropertyName = informationItem.name;
				if(isObjectItem) {
					if(isObjectCollection)
						continue;
					//sourcePropertyName = informationItem.name + ".ID";
					//targetPropertyName = informationItem.name + "ID";
                } else {
					//sourcePropertyName = informationItem.name;
					//targetPropertyName = informationItem.name;
                }
				if(isObjectItem && !isImplicitCollection) {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						objectToAdd.<#= targetPropertyName #>ID = serializedObject.<#= sourcePropertyName #>.ID;
					else
						objectToAdd.<#= targetPropertyName #>ID = null;
<#+

                } else if(!isImplicitCollection) {
#>
		            objectToAdd.<#= targetPropertyName #> = serializedObject.<#= sourcePropertyName #>;
<#+
                } else {
#>
					if(serializedObject.<#= sourcePropertyName #> != null)
						serializedObject.<#= sourcePropertyName #>.ForEach(item => objectToAdd.<#= targetPropertyName #>.Add(item));
<#+
                }
			} #>
					<#= informationObject.name #>Table.InsertOnSubmit(objectToAdd);
                    return;
                }
<#+	} #>
            }

		    public void PerformDelete(string storageRootPath, InformationObjectMetaData deleteData)
		    {
                if (deleteData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
				InformationObjectMetaDataTable.DeleteOnSubmit(deleteData);
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;

#>
		        if (deleteData.ObjectType == "<#= informationObject.name #>")
		        {
		            var objectToDelete = new <#= informationObject.name #> {ID = deleteData.ID};
                    <#= informationObject.name #>Table.Attach(objectToDelete);
                    <#= informationObject.name #>Table.DeleteOnSubmit(objectToDelete);
		            return;
		        }
<#+		} #>
		    }


<#+
		foreach(var informationObject in GetTableObjects(informationObjects))
        {
			string iObjName = informationObject.name;
#>
			public Table<<#= iObjName #>> <#= iObjName #>Table {
				get {
					return this.GetTable<<#= iObjName #>>();
				}
			}
<#+
        }
#>
        }

<#+

    }

	InformationObjectType[] GetTableObjects(InformationObjectType[] informationObjects) 
	{
		return informationObjects.Where(iObj => iObj.Item is InformationItemsType)
			.Where(iObj => GetSupportedInformationItems(((InformationItemsType) iObj.Item).InformationItem).Length > 0).ToArray();
    }

	void GenerateDataClasses(InstanceOfTheBallType instance) 
	{
		foreach(var iObj in GetTableObjects(instance.InformationModel)) 
		{
			GenerateDataClass(iObj);
        }
    }

	InformationItemType[] GetSupportedInformationItems(InformationItemType[] sourceItems) 
	{
		//var currentSupportedItems = sourceItems.Where(item => string.IsNullOrEmpty(item.informationObjectName)).ToArray();
		var currentSupportedItems = sourceItems.Where(item => item.name != "ParentCategoryID").ToArray();
		return currentSupportedItems;
    }

	void GenerateDataClass(InformationObjectType informationObject)
	{
		string semanticDomainName = CurrInstance.semanticDomainName;
		string objectName = informationObject.name;
		string informationObjectName = informationObject.name;
		CollectionForType collType = informationObject.Item as CollectionForType;
		bool isCollection = collType != null;

		InformationItemsType itemsType = informationObject.Item as InformationItemsType;
		//bool containsCollection = itemsType != null && itemsType.InformationItem.Any(item => item.isCollection);

		bool provideDefaultCreate = informationObject.provideCreateMethod;
		bool isIndependentMaster = informationObject.isIndependentMaster;

#>
    [Table(Name = "<#= objectName #>")]
	[ScaffoldTable(true)]
	public class <#= objectName #> : ITheBallDataContextStorable
	{
<#+
		var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
		GenerateSQLiteCreationFunction(objectName, currentSupportedItems);
#>

		[Column(IsPrimaryKey = true)]
        [ScaffoldColumn(true)]
        [Editable(false)]
		public string ID { get; set; }

		[Column]
        [ScaffoldColumn(true)]
        [Editable(false)]
		public string ETag { get; set; }


		public <#= objectName #>() 
		{
			ID = Guid.NewGuid().ToString();
			ETag = String.Empty;
		}

<#+
		GenerateInformationItems(informationObject, currentSupportedItems);
		GenerateInterfaceImplementation(currentSupportedItems);
#>
	}
<#+
    }

	void GenerateInterfaceImplementation(InformationItemType[] informationItems) 
	{
		var currentSupportedItems = GetSupportedInformationItems(informationItems);
		var customsStorableObjects = currentSupportedItems.Where(iItem => iItem.isCollection).ToArray();
		var stringItems = currentSupportedItems.Where(iItem => iItem.isCollection == false && GetPlatformDataTypeFromLogical(iItem.logicalDataType, iItem.informationObjectName) == "string").ToArray();

#>
        public void PrepareForStoring(bool isInitialInsert)
        {
		
<#+
		foreach(var stringItem in stringItems) 
		{
#>
			if(<#= stringItem.name #> == null)
				<#= stringItem.name #> = string.Empty;
<#+			
        }
		foreach(var item in customsStorableObjects) 
		{

#>
            if (_Is<#= item.name #>Changed || isInitialInsert)
            {
                var dataToStore = <#= item.name #>.ToArray();
                <#= item.name #>Data = JsonConvert.SerializeObject(dataToStore);
            }

<#+
        }

#>
		}
<#+
    }

	void GenerateSQLiteCreationFunction(string informationObjectName, InformationItemType[] informationItems) 
    {
#>
        public static string GetCreateTableSQL()
        {
            return
                @"
CREATE TABLE IF NOT EXISTS [<#= informationObjectName #>](
[ID] TEXT NOT NULL PRIMARY KEY, 
[ETag] TEXT NOT NULL
<#+
			var itemArray = informationItems.Select(item => {
				Tuple<string, string, string> fieldData = GetSQLFieldNameDataTypeNullDeclaration(item);
				if(fieldData == null)
					return null;
				var fieldName = fieldData.Item1;
				var dataType = fieldData.Item2;
				var notNullClause = fieldData.Item3;
				return string.Format("[{0}] {1} {2}", fieldName, dataType, notNullClause);
            }).Where(clause => clause != null).ToArray();
			string wholePart = string.Join(", " + Environment.NewLine, itemArray);
			if(wholePart != string.Empty)
				wholePart = ", " + Environment.NewLine + wholePart;
#><#= wholePart #>
)";
        }

<#+
    }

	Tuple<string, string, string> GetSQLFieldNameDataTypeNullDeclaration(InformationItemType item) {
		bool isObjectType = item.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
		string fieldName;
		string dataType;
		string notNullClause;
		if(!isObjectType) 
		{
			fieldName = item.name;
			dataType = GetSQLiteTypeFromLogicalType(item.logicalDataType);
			if(item.isCollection || isObjectType)
				dataType = "TEXT";
			notNullClause = "NOT NULL";
			return new Tuple<string, string, string>(fieldName, dataType, notNullClause);
        } else {
			ObjectType objType = GetInformationObjectType(item.informationObjectName);
			dataType = "TEXT";
			if(objType == ObjectType.Items || objType == ObjectType.MediaContent)
				fieldName = item.name + "ID";
			else 
				return null;
			notNullClause = "NULL";
        }
		return new Tuple<string, string, string>(fieldName, dataType, notNullClause);
    }

	void GenerateInformationItemsMethods(string informationObjectName, InformationItemType[] informationItems)
	{
		InformationItemType[] informationObjects = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName) == false).ToArray();
		//InformationItemType[] nonMasterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == false).ToArray();
		//InformationItemType[] masterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == true).ToArray();
		InformationItemType[] primitiveItems = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName)).ToArray();
		bool containsCollection = informationItems.Any(item => item.isCollection);
		string domainName = CurrentAbstraction.InstanceOfTheBall.semanticDomainName;
		if(containsCollection == false) {
        }
    }
	
	void GenerateInformationItems(InformationObjectType iObj, InformationItemType[] informationItems)
	{
		foreach(var item in informationItems)
		{
			if(item.logicalDataType != InformationItemTypeLogicalDataType.InformationObject || item.isCollection) 
				GenerateDataItem(iObj, item);
			else
				GenerateEntityItem(iObj, item);
        }
    }

	void GenerateEntityItem(InformationObjectType iObj, InformationItemType item)
    {
		string objectName = item.informationObjectName;
		//if(ItemTypesToIgnore.Contains(objectName))
		//	return;
		if(item.isCollection)  // Generated as data item with serializable type
			return;
		ObjectType objectType = GetInformationObjectType(objectName);
		if(objectType == ObjectType.Collection) {
			var collectionObject = GetInformationObjectByName(objectName);
			var collectionFor = (CollectionForType) collectionObject.Item;
			var linkedObjectName = collectionFor.contentInformationObjectName;

        } else if(objectType == ObjectType.MediaContent) {
			string objectPropName = item.name;
			string idPropName = objectPropName + "ID";
#>
			[Column]
			public string <#= idPropName #> { get; set; }
<#+
        } else { // items
			string objectPropName = item.name;
			string idPropName = objectPropName + "ID";
#>
			[Column]
			public string <#= idPropName #> { get; set; }
			private EntityRef< <#= objectName #> > _<#= objectPropName #>;
			[Association(Storage = "_<#= objectPropName  #>", ThisKey = "<#= idPropName #>")]
			public <#= objectName #> <#= objectPropName #>
			{
				get { return this._<#= objectPropName #>.Entity; }
				set { this._<#= objectPropName #>.Entity = value; }
			}

<#+
        }
    }

	void GenerateDataItem(InformationObjectType iObj, InformationItemType item) 
	{
		if(iObj.name == "Category" && item.name == "ParentCategoryID")
			return;
		string dataType = GetPlatformDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
		bool isObjectItem = item.logicalDataType == InformationItemTypeLogicalDataType.InformationObject;
		bool isCollection = item.isCollection;
		if(isCollection)
        {
			string dataTypePrefix = isObjectItem ? "SER." + CurrentAbstraction.InstanceOfTheBall.semanticDomainName + "." : "";
			dataType = dataTypePrefix + dataType;
#>
        [Column(Name = "<#= item.name #>")] 
        [ScaffoldColumn(true)]
		public string <#= item.name #>Data { get; set; }

        private bool _Is<#= item.name #>Retrieved = false;
        private bool _Is<#= item.name #>Changed = false;
        private ObservableCollection<<#= dataType #>> _<#= item.name #> = null;
        public ObservableCollection<<#= dataType #>> <#= item.name #>
        {
            get
            {
                if (!_Is<#= item.name #>Retrieved)
                {
                    if (<#= item.name #>Data != null)
                    {
                        var arrayData = JsonConvert.DeserializeObject<<#= dataType #>[]>(<#= item.name #>Data);
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>(arrayData);
                    }
                    else
                    {
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>();
						<#= item.name #>Data = Guid.NewGuid().ToString();
						_Is<#= item.name #>Changed = true;
                    }
                    _Is<#= item.name #>Retrieved = true;
                    _<#= item.name #>.CollectionChanged += (sender, args) =>
						{
							<#= item.name #>Data = Guid.NewGuid().ToString();
							_Is<#= item.name #>Changed = true;
						};
                }
                return _<#= item.name #>;
            }
            set 
			{ 
				_<#= item.name #> = value; 
                // Reset the data field to unique value
                // to trigger change on object, just in case nothing else changed
                _Is<#= item.name #>Retrieved = true;
                <#= item.name #>Data = Guid.NewGuid().ToString();
                _Is<#= item.name #>Changed = true;

			}
        }

<#+
        } else {
#>

		[Column]
        [ScaffoldColumn(true)]
		public <#= dataType #> <#= item.name #> { get; set; }
		// private <#= dataType #> _unmodified_<#= item.name #>;
<#+
        }
	}

	string GetPlatformDataTypeFromLogical(InformationItemTypeLogicalDataType logicalDataType, string informationObjectName)
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
				return "double";
			//case InformationItemTypeLogicalDataType.Number_CustomFormat:
			//	return "string";
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "double";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "long";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
				return "string";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InformationItemTypeLogicalDataType.InformationObject:
				return informationObjectName;
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
	}

	string GetSQLiteTypeFromLogicalType(InformationItemTypeLogicalDataType logicalDataType) 
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "BLOB";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "REAL";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
				return "TEXT";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "TEXT";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.InformationObject:
				return "TEXT";
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
    }



#>