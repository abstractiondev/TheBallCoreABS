<#@ template debug="true" hostSpecific="true" #>
<#@ output extension="?" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Serialization" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ include file="..\..\abscommon\CommonInclude\Common\CommonCodeblocks.ttinclude" #>
<#@ include file="TheBallCore_v1_0.ttinclude" #>
<#   
	// Set abstraction specific type and single file specific extension
	//TransformGenerator< ClassModelAbstractionType >(GenerateRoot, ".designer.cs");	
	GenerateRoot();
#>

<#+ 
	public Tuple<string, string>[] GetGeneratorContent(params string[] xmlFileNames)
	{
		List<Tuple<string, string>> result = new List<Tuple<string, string>>();
		foreach(string xmlFileName in xmlFileNames)
		{
			TheBallCoreAbstractionType abs = LoadXml<TheBallCoreAbstractionType>(xmlFileName);
			CurrentAbstraction = abs;
			this.GenerationEnvironment.Clear();
			string content = TransformText();
			string outputFile = Path.GetFileNameWithoutExtension(xmlFileName) + "_SQLite.designer.cs";
			result.Add(Tuple.Create(outputFile, content));
		}
		return result.ToArray();
	}
	
	void SetCurrentAbstraction(object abs)
	{
		CurrentAbstraction = ( TheBallCoreAbstractionType ) abs;
	}
	
	TheBallCoreAbstractionType CurrentAbstraction;
	InstanceOfTheBallType CurrInstance;
	
	void GenerateRoot()
	{
		GenerateAbstraction(CurrentAbstraction);
	}

	void GenerateAbstraction(TheBallCoreAbstractionType abstraction)
	{
		InstanceOfTheBallType instance = abstraction.InstanceOfTheBall;
		CurrInstance = instance;
		GenerateInstance(instance);
	}	

	InformationObjectType GetInformationObjectByName(string informationObjectName)
    {
		var result = CurrInstance.InformationModel.FirstOrDefault(candidate => candidate.name == informationObjectName);
		if(result == null)
			throw new ArgumentException("Information object not found with name: " + informationObjectName);
		return result;
    }


	void GenerateInstance(InstanceOfTheBallType instance)
	{
		string domainName = instance.semanticDomainName;
		string domainNameMethodPart = domainName.Replace(".", "_");
#>

using System;
using System.Collections.ObjectModel;
using System.Data;
using System.Data.SQLite;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Xml;
using System.Linq;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters.Binary;
using Newtonsoft.Json;
using SQLiteSupport;


<#+
		BeginNamespace("SQLite." + instance.semanticDomainName);
		GenerateRequiredInterfaceDefinitions(instance);
		GenerateDataContext(instance);
		GenerateDataClasses(instance);
		EndBlock();
#>


<#+
	}

	string GetTypeFromInterfaceType(InterfaceItemTypeLogicalDataType logicalInterfaceDataType)
    {
		//InterfaceItemTypeLogicalDataType dataType = (InterfaceItemTypeLogicalDataType) System.Enum.Parse(typeof(InterfaceItemTypeLogicalDataType), logicalInterfaceDataType);
		switch(logicalInterfaceDataType)
        {
			case InterfaceItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InterfaceItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InterfaceItemTypeLogicalDataType.Number:
				return "double";
			case InterfaceItemTypeLogicalDataType.Text_Long:
			case InterfaceItemTypeLogicalDataType.Text_Short:
				return "string";
			case InterfaceItemTypeLogicalDataType.Time_Date:
			case InterfaceItemTypeLogicalDataType.Time_DateTime:
			case InterfaceItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			default:
				throw new NotSupportedException("Logical interface data type not supported: " + logicalInterfaceDataType);
        }
    }

	void GenerateRequiredInterfaceDefinitions(InstanceOfTheBallType instance) 
	{
#>

	internal interface ITheBallDataContextStorable
	{
		void PrepareForStoring(bool isInitialInsert);
	}

<#+
    }

	void GenerateDataContext(InstanceOfTheBallType instance)
    {
		var informationObjects = instance.InformationModel;
		string instanceName = instance.semanticDomainName;
		var tableObjects = GetTableObjects(instance.InformationModel);
#>
		public class TheBallDataContext : DataContext, IStorageSyncableDataContext
		{
            // Track whether Dispose has been called. 
            private bool disposed = false;
		    protected override void Dispose(bool disposing)
		    {
		        if (disposed)
		            return;
                base.Dispose(disposing);
                GC.Collect();
                GC.WaitForPendingFinalizers();
		        disposed = true;
		    }

		    public static TheBallDataContext CreateOrAttachToExistingDB(string pathToDBFile)
		    {
		        SQLiteConnection connection = new SQLiteConnection(String.Format("Data Source={0}", pathToDBFile));
                var dataContext = new TheBallDataContext(connection);
				dataContext.CreateDomainDatabaseTablesIfNotExists();
				return dataContext;
		    }

            public TheBallDataContext(SQLiteConnection connection) : base(connection)
		    {
                if(connection.State != ConnectionState.Open)
                    connection.Open();
		    }

            public override void SubmitChanges(ConflictMode failureMode)
            {
                var changeSet = GetChangeSet();
                var insertsToProcess = changeSet.Inserts.Where(insert => insert is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in insertsToProcess)
                    itemToProcess.PrepareForStoring(true);
                var updatesToProcess = changeSet.Updates.Where(update => update is ITheBallDataContextStorable).Cast<ITheBallDataContextStorable>().ToArray();
                foreach (var itemToProcess in updatesToProcess)
                    itemToProcess.PrepareForStoring(false);
                base.SubmitChanges(failureMode);
            }

			public void CreateDomainDatabaseTablesIfNotExists()
			{
				List<string> tableCreationCommands = new List<string>();
                tableCreationCommands.AddRange(InformationObjectMetaData.GetMetaDataTableCreateSQLs());
<#+
		foreach(var informationObject in tableObjects)
        {
			string iObjName = informationObject.name;
#>
				tableCreationCommands.Add(<#= iObjName #>.GetCreateTableSQL());
<#+
        }
#>
			    var connection = this.Connection;
				foreach (string commandText in tableCreationCommands)
			    {
			        var command = connection.CreateCommand();
			        command.CommandText = commandText;
                    command.CommandType = CommandType.Text;
			        command.ExecuteNonQuery();
			    }
			}

			public Table<InformationObjectMetaData> InformationObjectMetaDataTable {
				get {
					return this.GetTable<InformationObjectMetaData>();
				}
			}

			public void PerformUpdate(string storageRootPath, InformationObjectMetaData updateData)
		    {
                if(updateData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
#>
		        if (updateData.ObjectType == "<#= informationObject.name #>")
		        {
		            string currentFullStoragePath = Path.Combine(storageRootPath, updateData.CurrentStoragePath);
		            var serializedObject =
		                global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
		                    ContentStorage.GetContentAsString(currentFullStoragePath));
		            var existingObject = <#= informationObject.name #>Table.Single(item => item.ID == updateData.ObjectID);
<#+
			foreach(var informationItem in currentSupportedItems) 
			{
				bool isCollection = informationItem.isCollection;
				string propertyName = informationItem.name;
				if(!isCollection) {
#>
		            existingObject.<#= propertyName #> = serializedObject.<#= propertyName #>;
<#+
                } else {
#>
                    existingObject.<#= propertyName #>.Clear();
					if(serializedObject.<#= propertyName #> != null)
	                    serializedObject.<#= propertyName #>.ForEach(item => existingObject.<#= propertyName #>.Add(item));
					
<#+
                }
			} #>
		            return;
		        } 
<#+
        }
#>
		    }

		    public void PerformInsert(string storageRootPath, InformationObjectMetaData insertData)
		    {
                if (insertData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
                InformationObjectMetaDataTable.InsertOnSubmit(insertData);
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;
				var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);

#>
                if (insertData.ObjectType == "<#= informationObject.name #>")
                {
                    string currentFullStoragePath = Path.Combine(storageRootPath, insertData.CurrentStoragePath);
                    var serializedObject =
                        global::SER.<#= CurrInstance.semanticDomainName #>.<#= informationObject.name #>.DeserializeFromXml(
                            ContentStorage.GetContentAsString(currentFullStoragePath));
                    var objectToAdd = new <#= informationObject.name #> {ID = insertData.ObjectID};
<#+
			foreach(var informationItem in currentSupportedItems) 
			{
				bool isCollection = informationItem.isCollection;
				string propertyName = informationItem.name;
				if(!isCollection) {
#>
		            objectToAdd.<#= propertyName #> = serializedObject.<#= propertyName #>;
<#+
                } else {
#>
					if(serializedObject.<#= propertyName #> != null)
						serializedObject.<#= propertyName #>.ForEach(item => objectToAdd.<#= propertyName #>.Add(item));
<#+
                }
			} #>
					<#= informationObject.name #>Table.InsertOnSubmit(objectToAdd);
                    return;
                }
<#+	} #>
            }

		    public void PerformDelete(string storageRootPath, InformationObjectMetaData deleteData)
		    {
                if (deleteData.SemanticDomain != "<#= CurrInstance.semanticDomainName #>")
                    throw new InvalidDataException("Mismatch on domain data");
				InformationObjectMetaDataTable.DeleteOnSubmit(deleteData);
<#+
		foreach(InformationObjectType informationObject in tableObjects) 
        {
				InformationItemsType itemsType = informationObject.Item as InformationItemsType;

#>
		        if (deleteData.ObjectType == "<#= informationObject.name #>")
		        {
                    <#= informationObject.name #>Table.DeleteOnSubmit(new <#= informationObject.name #> { ID = deleteData.ObjectID });
		            return;
		        }
<#+		} #>
		    }


<#+
		foreach(var informationObject in GetTableObjects(informationObjects))
        {
			string iObjName = informationObject.name;
#>
			public Table<<#= iObjName #>> <#= iObjName #>Table {
				get {
					return this.GetTable<<#= iObjName #>>();
				}
			}
<#+
        }
#>
        }

<#+

    }

	InformationObjectType[] GetTableObjects(InformationObjectType[] informationObjects) 
	{
		return informationObjects.Where(iObj => iObj.Item is InformationItemsType)
			.Where(iObj => GetSupportedInformationItems(((InformationItemsType) iObj.Item).InformationItem).Length > 0).ToArray();
    }

	void GenerateDataClasses(InstanceOfTheBallType instance) 
	{
		foreach(var iObj in GetTableObjects(instance.InformationModel)) 
		{
			GenerateDataClass(iObj);
        }
    }

	InformationItemType[] GetSupportedInformationItems(InformationItemType[] sourceItems) 
	{
		var currentSupportedItems = sourceItems.Where(item => string.IsNullOrEmpty(item.informationObjectName)).ToArray();
		return currentSupportedItems;
    }

	void GenerateDataClass(InformationObjectType informationObject)
	{
		string semanticDomainName = CurrInstance.semanticDomainName;
		string objectName = informationObject.name;
		string informationObjectName = informationObject.name;
		CollectionForType collType = informationObject.Item as CollectionForType;
		bool isCollection = collType != null;

		InformationItemsType itemsType = informationObject.Item as InformationItemsType;
		//bool containsCollection = itemsType != null && itemsType.InformationItem.Any(item => item.isCollection);

		bool provideDefaultCreate = informationObject.provideCreateMethod;
		bool isIndependentMaster = informationObject.isIndependentMaster;

#>
    [Table(Name = "<#= objectName #>")]
	public class <#= objectName #> : ITheBallDataContextStorable
	{
<#+
		var currentSupportedItems = GetSupportedInformationItems(itemsType.InformationItem);
		GenerateSQLiteCreationFunction(objectName, currentSupportedItems);
#>

		[Column(IsPrimaryKey = true)]
		public string ID { get; set; }

<#+
		GenerateInformationItems(currentSupportedItems);
		GenerateInterfaceImplementation(currentSupportedItems);
#>
	}
<#+
    }

	void GenerateInterfaceImplementation(InformationItemType[] informationItems) 
	{
		var currentSupportedItems = GetSupportedInformationItems(informationItems);
		var customsStorableObjects = currentSupportedItems.Where(iItem => iItem.isCollection).ToArray();
		var stringItems = currentSupportedItems.Where(iItem => iItem.isCollection == false && GetPlatformDataTypeFromLogical(iItem.logicalDataType, iItem.informationObjectName) == "string").ToArray();

#>
        public void PrepareForStoring(bool isInitialInsert)
        {
		
<#+
		foreach(var stringItem in stringItems) 
		{
#>
			if(<#= stringItem.name #> == null)
				<#= stringItem.name #> = string.Empty;
<#+			
        }
		foreach(var item in customsStorableObjects) 
		{

#>
            if (_Is<#= item.name #>Changed || isInitialInsert)
            {
                var dataToStore = <#= item.name #>.ToArray();
                <#= item.name #>Data = JsonConvert.SerializeObject(dataToStore);
            }

<#+
        }

#>
		}
<#+
    }

	void GenerateSQLiteCreationFunction(string informationObjectName, InformationItemType[] informationItems) 
    {
#>
        public static string GetCreateTableSQL()
        {
            return
                @"
CREATE TABLE IF NOT EXISTS [<#= informationObjectName #>](
[ID] TEXT NOT NULL PRIMARY KEY, 
<#+
			var itemArray = informationItems.Select(item => {
				string itemDataType = GetSQLiteTypeFromLogicalType(item.logicalDataType);
				if(item.isCollection)
					itemDataType = "TEXT";
				return string.Format("[{0}] {1} NOT NULL", item.name, itemDataType);
            }).ToArray();
			string wholePart = string.Join(", " + Environment.NewLine, itemArray);
#><#= wholePart #>
)";
        }

<#+
    }

	void GenerateInformationItemsMethods(string informationObjectName, InformationItemType[] informationItems)
	{
		InformationItemType[] informationObjects = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName) == false).ToArray();
		//InformationItemType[] nonMasterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == false).ToArray();
		//InformationItemType[] masterInformationObjects = informationObjects.Where(iObject => IsObjectIndependentMaster(iObject.informationObjectName) == true).ToArray();
		InformationItemType[] primitiveItems = informationItems.Where(item => String.IsNullOrEmpty(item.informationObjectName)).ToArray();
		bool containsCollection = informationItems.Any(item => item.isCollection);
		string domainName = CurrentAbstraction.InstanceOfTheBall.semanticDomainName;
		if(containsCollection == false) {
        }
    }
	
	void GenerateInformationItems(InformationItemType[] informationItems)
	{
		foreach(var item in informationItems)
		{
			string dataType = GetPlatformDataTypeFromLogical(item.logicalDataType, item.informationObjectName);
			bool isCollection = item.isCollection;
			if(isCollection)
            {
#>
        [Column(Name = "<#= item.name #>")] public string <#= item.name #>Data;

        private bool _Is<#= item.name #>Retrieved = false;
        private bool _Is<#= item.name #>Changed = false;
        private ObservableCollection<<#= dataType #>> _<#= item.name #> = null;
        public ObservableCollection<<#= dataType #>> <#= item.name #>
        {
            get
            {
                if (!_Is<#= item.name #>Retrieved)
                {
                    if (<#= item.name #>Data != null)
                    {
                        var arrayData = JsonConvert.DeserializeObject<<#= dataType #>[]>(<#= item.name #>Data);
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>(arrayData);
                    }
                    else
                    {
                        _<#= item.name #> = new ObservableCollection<<#= dataType #>>();
						<#= item.name #>Data = Guid.NewGuid().ToString();
						_Is<#= item.name #>Changed = true;
                    }
                    _Is<#= item.name #>Retrieved = true;
                    _<#= item.name #>.CollectionChanged += (sender, args) =>
						{
							<#= item.name #>Data = Guid.NewGuid().ToString();
							_Is<#= item.name #>Changed = true;
						};
                }
                return _<#= item.name #>;
            }
            set 
			{ 
				_<#= item.name #> = value; 
                // Reset the data field to unique value
                // to trigger change on object, just in case nothing else changed
                _Is<#= item.name #>Retrieved = true;
                <#= item.name #>Data = Guid.NewGuid().ToString();
                _Is<#= item.name #>Changed = true;

			}
        }

<#+
            } else {
#>

		[Column]
		public <#= dataType #> <#= item.name #> { get; set; }
		// private <#= dataType #> _unmodified_<#= item.name #>;
<#+
            }
		}
	}

	string GetPlatformDataTypeFromLogical(InformationItemTypeLogicalDataType logicalDataType, string informationObjectName)
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "byte[]";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
				return "double";
			//case InformationItemTypeLogicalDataType.Number_CustomFormat:
			//	return "string";
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "double";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "long";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
				return "string";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "DateTime";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "bool";
			case InformationItemTypeLogicalDataType.InformationObject:
				return informationObjectName;
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
	}

	string GetSQLiteTypeFromLogicalType(InformationItemTypeLogicalDataType logicalDataType) 
	{
		switch(logicalDataType)
		{
			case InformationItemTypeLogicalDataType.Data_Binary:
				return "BLOB";
			case InformationItemTypeLogicalDataType.Number_ApproxDecimal:
			case InformationItemTypeLogicalDataType.Number_ExactDecimal:
				return "REAL";
			case InformationItemTypeLogicalDataType.Number_Integer:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.Text_Short:
			case InformationItemTypeLogicalDataType.Text_Long:
				return "TEXT";
			case InformationItemTypeLogicalDataType.Time_Date:
			case InformationItemTypeLogicalDataType.Time_DateTime:
			case InformationItemTypeLogicalDataType.Time_Time:
				return "TEXT";
			case InformationItemTypeLogicalDataType.TrueOrFalse_Boolean:
				return "INTEGER";
			case InformationItemTypeLogicalDataType.InformationObject:
				return "TEXT";
			default:
				throw new NotSupportedException("Logical data type not recognized: " + logicalDataType.ToString());
		}
    }



#>